<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>PostgreSQL FAQ</title>
</head>
<body bgcolor="#FFFFFF" text="#000000" link="#FF0000" vlink="#A00000" alink="#0000FF">
<h1>
Häufig gestellte Fragen (FAQ) zu PostgreSQL
</h1>
<p>
Current maintainer:	Bruce Momjian (<a
href="mailto:pgman@candle.pha.pa.us">pgman@candle.pha.pa.us</a>).</p>

    <p>Deutsche Übersetzung von Ian Barwick (<a href="mailto:barwick@gmx.net">barwick@gmx.net</a>).</p>

    <p>Letzte Aktualisierung der deutschen Übersetzung: So., den 16.1.2005, 22:30 MEZ</p>

    <p>Die aktuellste Version dieses Dokuments liegt auf der PostgreSQL-Website:</p>
    <ul>
      <li><a href="http://www.postgresql.org/files/documentation/faqs/FAQ.html">http://www.postgresql.org/files/documentation/faqs/FAQ.html</a> (engl.)</li>
      <li><a href="http://www.postgresql.org/files/documentation/faqs/FAQ_german.html">http://www.postgresql.org/files/documentation/faqs/FAQ_german.html</a> (dt.)</li>
    </ul>
    <p>Übersetzungen dieses Dokuments in andere Sprachen sowie plattform-
    spezifische FAQs können unter
    <a href="http://www.postgresql.org/docs/faq/">http://www.postgresql.org/docs/faq/</a>
    eingesehen werden.</p>

<hr />

<h2 align="center">Allgemeine Fragen</h2>

<a href="#1.1">1.1</a>) Was ist PostgreSQL? Wie wird es ausgesprochen?<br />
<a href="#1.2">1.2</a>) Welchem Copyright unterliegt PostgreSQL?<br />
<a href="#1.3">1.3</a>) Auf welchen Unix-Plattformen läuft PostgreSQL?<br />
<a href="#1.4">1.4</a>) Welche Nicht-Unix-Versionen sind verfügbar?<br />
<a href="#1.5">1.5</a>) Woher bekomme ich PostgreSQL?<br />
<a href="#1.6">1.6</a>) Wo bekomme ich Support für PostgreSQL?<br />
<a href="#1.7">1.7</a>) Was ist die neueste Version von PostgreSQL?<br />
<a href="#1.8">1.8</a>) Welche Dokumentation ist für PostgreSQL verfügbar?<br />
<a href="#1.9">1.9</a>) Wie erfahre ich von bekannten Bugs oder fehlenden Features?<br />
<a href="#1.10">1.10</a>) Wie kann ich SQL lernen?<br />
<a href="#1.11">1.11</a>) Ist PostgreSQL Y2K (Jahr 2000) fähig?<br />
<a href="#1.12">1.12</a>) Wie kann ich im Entwicklerteam mitarbeiten?<br />
<a href="#1.13">1.13</a>) Wie sende ich einen Fehler-Bericht?<br />
<a href="#1.14">1.14</a>) Wie läuft PostgreSQL im Vergleich zu anderen Datenbanksystemen?<br />
<a href="#1.15">1.15</a>) Wie kann ich PostgreSQL finanziell unterstützen?

<h2 align="center">Fragen zu Benutzerprogrammen</h2>

<a href="#2.1">2.1</a>) Gibt es ODBC-Treiber für PostgreSQL?<br />
<a href="#2.2">2.2</a>) Welche Werkzeuge gibt es, um Web-Seiten mit PostgreSQL zu verbinden?<br />
<a href="#2.3">2.3</a>) Hat PostgreSQL eine grafische Benutzerschnittstelle?<br />
<a href="#2.4">2.4</a>) Welche Programmiersprachen können mit PostgreSQL kommunizieren?<br />


<h2 align="center">Administrative Fragen</h2>

<a href="#3.1">3.1</a>) Wie installiere ich PostgreSQL woanders als in /usr/local/pgsql?<br />
<a href="#3.2">3.2</a>) Wenn ich den <em>postmaster</em> starte, erhalte ich die Nachricht "<em>Bad System Call</em>" bzw. "<em>core dumped</em>". Warum?<br />
<a href="#3.3">3.3</a>) Wenn ich versuche, den <em>postmaster</em> zu starten, bekomme ich "<em>IpcMemoryCreate</em>"-Fehlermeldungen. Warum?<br />
<a href="#3.4">3.4</a>) Wenn ich versuche, den <em>postmaster</em> zu starten, bekomme ich "<em>IpcSemaphoreCreate</em>"-Fehlermeldungen. Warum?<br />
<a href="#3.5">3.5</a>) Wie regle ich Zugriffe von anderen Rechnern?<br />
<a href="#3.6">3.6</a>) Wie optimiere ich die Datenbank für bessere Leistung?<br />
<a href="#3.7">3.7</a>) Welche Debugging-Funktionen sind bei PostgreSQL verfügbar?<br />
<a href="#3.8">3.8</a>) Ich bekomme die Meldung "<em>Sorry, too many clients</em>", wenn ich eine Verbindung aufzubauen versuche. Warum?<br />
<a href="#3.9">3.9</a>) Was befindet sich im Verzeichnis <em>pgsql_tmp/</em>?<br />
<a href="#3.10">3.10</a>) Warum muß ich bei jeder neuen Hauptversion von PostgreSQL
     die komplette Datenbank exportieren und anschließend reimportieren?<br />
<a href="#3.11">3.11</a>) Welche Hardware eignet sich für den Betrieb mit PostgreSQL?<br />
<h2 align="center">Fragen zum Betrieb</h2>

<a href="#4.1">4.1</a>) Worin besteht der Unterschied zwischen <em>Binary Cursors</em> und <em>Normal Cursors?</em><br />
<a href="#4.2">4.2</a>) Wie wähle ich per <small>SELECT</small>-Anweisung nur die
     ersten paar Zeilen bzw. eine beliebige Zeile in einer Abfrage aus?<br />
<a href="#4.3">4.3</a>) Wie finde ich heraus, welche Tabellen, Indizes, Datenbanken oder Benutzer in der Datenbank definiert sind? Wie bekomme ich die von <em>psql</em> verwendeten Abfragen?<br />
<a href="#4.4">4.4</a>) Wie entferne ich eine Spalte aus einer Tabelle? Wie ändere 
    ich den Datentyp einer Spalte?<br />
<a href="#4.5">4.5</a>) Was ist die Maximalgröße für eine Zeile, eine Tabelle, eine Datenbank?<br />
<a href="#4.6">4.6</a>) Wieviel Plattenplatz wird benötigt, um die Daten aus einer typischen Textdatei abzuspeichern?<br />
<a href="#4.7">4.7</a>) Meine Abfragen sind langsam oder nutzen die Indizes nicht. Warum?<br />
<a href="#4.8">4.8</a>) Auf welche Weise kann ich sehen, wie der Abfrage-Optimierer ("<em>GEQO</em>") meine Abfrage auswertet?<br />
<a href="#4.9">4.9</a>) Was ist ein R-Tree Index?<br />
<a href="#4.10">4.10</a>) Was ist der "Genetic Query Optimizer"?<br />
<a href="#4.11">4.11</a>) Wie verfahre ich bei der Suche mit regulären Ausdrücken und bei einer
    Suche, bei der Groß- und Kleinschreibweisen ignoriert werden? Wie verwende
    ich bei solchen Suchabfragen einen Index?<br />
<a href="#4.12">4.12</a>) Wie ermittle ich in einer Abfrage, ob ein Feld NULL ist?<br />
<a href="#4.13">4.13</a>) Was ist der Unterschied zwischen den verschiedenen CHAR-Typen?<br />
<a href="#4.14.1">4.14.1</a>) Wie erzeuge ich ein serielles Feld mit automatischer Erhöhung des Wertes?<br />
<a href="#4.14.2">4.14.2</a>) Wie bekomme ich den Wert einer SERIAL-Sequenz?<br />
<a href="#4.14.3">4.14.3</a>) Führt currval() zu einer Race-Condition mit anderen Nutzern?<br />
<a href="#4.14.4">4.14.4</a>) Warum werden die Sequenzwerte nach einem Transaktionsabbruch nicht
     zurückgesetzt? Warum gibt es Lücken in der Nummerierung meiner
     Sequenz-/<small>SERIAL</small>-Spalte?<br />
<a href="#4.15">4.15</a>) Was ist ein <small>OID</small>? Was ist ein <small>TID</small>?<br />
<a href="#4.16">4.16</a>) Welche Bedeutung haben die verschiedenen Ausdrücke, die in PostgreSQL benutzt werden (z.B. attribute, class,...)?<br />
<a href="#4.17">4.17</a>) Wieso bekomme ich den Fehler: "<em>FATAL: Memory exhausted in AllocSetAlloc()</em>"?<br />
<a href="#4.18">4.18</a>) Wie kann ich feststellen, welche PostgreSQL-Version bei mir läuft?<br />
<a href="#4.19">4.19</a>) Bei "large-object"-Operationen kommt die Fehlermeldung: "<em>invalid large obj descriptor</em>". Warum?<br />
<a href="#4.20">4.20</a>) Wie kann ich eine Spalte erstellen, deren Default-Wert immer
    die aktuelle Uhrzeit enthalten soll?<br />
<a href="#4.21">4.21</a>) Warum sind meine Unterabfragen (subqueries), die IN verwenden,
    so langsam?<br />
<a href="#4.22">4.22</a>) Wie führe ich einen <small>OUTER JOIN</small> durch?<br />
<a href="#4.23">4.23</a>) Wie kann ich Abfragen über mehrere Datenbanken hinweg ausführen?<br />
<a href="#4.24">4.24</a>) Wie kann ich mehrere Zeilen bzw. Spalten von einer Funktion
    zurückgeben lassen?<br />
<a href="#4.25">4.25</a>) Warum kann ich temporäre Tabellen in <small>PL/PgSQL</small>-Funktionen nicht
    zuverlässig erstellen bzw. löschen?<br />
<a href="#4.26">4.26</a>) Welche Möglichkeiten zur Verschlüsselung gibt es?<br />


<h2 align="center">PostgreSQL erweitern</h2>

<a href="#5.1">5.1</a>) Ich habe eine benutzerdefinierte Funktion geschrieben.  Wenn ich sie in <em>psql</em> aufrufe, kommt ein <em>core dump</em>. Warum?<br />
<a href="#5.2">5.2</a>) Wie kann ich praktische neue Typen und Funktionen zu PostgreSQL
    hinzufügen?<br />
<a href="#5.3">5.3</a>) Wie schreibe ich eine Funktion in C, die einen Tupel zurückliefert?<br />
<a href="#5.4">5.4</a>) Ich habe eine der Quellendateien geändert. Warum macht sich die Änderung beim erneuten Kompilieren nicht bemerkbar?<br />

<hr />

    <h2 align="center">Allgemeine Fragen</h2>
    <h4><a name="1.1">1.1</a>)	Was ist PostgreSQL? Wie wird es ausgesprochen?</h4>
    <p>Die (englische) Aussprache ist "Post-Gres-Q-L". Im allgemeinen
    Sprachgebrauch hat sich die Kurzform "Postgres" auch durchgesetzt.</p>

    <p>PostgreSQL ist eine Weiterentwicklung des POSTGRES-Datenbank-Systems,
    eines zukunftsweisenden DBMS-Forschungsprototyps. Während PostgreSQL
    das leistungsfähige Datenmodell und die reichhaltigen Datentypen
    von POSTGRES beibehält, ersetzt es dessen PostQuel-Abfragesprache durch
    eine erweiterte Teilmenge von SQL. PostgreSQL und dessen kompletter
    Quellcode sind frei und öffentlich verfügbar.</p>

    <p>Die PostgreSQL-Entwicklung wird von einem Entwickler-Team durchgeführt,
    die alle Teilnehmer der PostgreSQL-Entwicklungs-Mailingliste
    sind. Der aktuelle Koordinator ist Marc G. Fournier
    (<a href="mailto:scrappy@postgresql.org">scrappy@postgresql.org</a>) (Anmeldemöglichkeit: siehe unten).
    Dieses Team ist für die Gesamtentwicklung von PostgreSQL
    verantwortlich. Es handelt sich um ein Gemeinschaftsprojekt, das nicht
    von einer bestimmten Firma kontrolliert wird. Lesen Sie die Entwickler-FAQ:
    <a href="http://www.postgresql.org/docs/faqs/FAQ_DEV.html">http://www.postgresql.org/docs/faqs/FAQ_DEV.html</a>
    wenn Sie an einer Mitarbeit interessiert sind.</p>

    <p>Die Autoren von PostgreSQL 1.01 waren Andrew Yu und Jolly Chen. Viele
    andere haben zur Portierung, zum Testen, zur Fehlersuche und zur
    Verbesserung des Codes beigetragen. Der ursprüngliche Postgres-Code,
    von dem PostgreSQL abstammt, ist auf die Arbeit von vielen
    Studierenden und Diplomanden sowie Programmierern zurückzuführen,
    die unter der Leitung des Professors Michael Stonebraker an der
    Universität von Kalifornien, Berkeley arbeiteten.</p>

    <p>Der ursprüngliche Name der Software in Berkeley war Postgres. Als die
    SQL-Funktionalität 1995 hinzugefügt wurde, wurde sein Name zu
    Postgres95 erweitert. Der Name wurde Ende 1996 in PostgreSQL geändert.</p>

    <h4><a name="1.2">1.2</a>).Welchem Copyright unterliegt PostgreSQL?</h4>

    <p>PostgreSQL unterliegt folgendem COPYRIGHT (Originaltext):</p>

    <p>PostgreSQL Data Base Management System</p>

    <P>Portions Copyright (c) 1996-2007, PostgreSQL Global Development Group
    Portions Copyright (c) 1994-6 Regents of the University of California</P>

    <p>Permission to use, copy, modify, and distribute this software
    and its documentation for any purpose, without fee, and without a
    written agreement is hereby granted, provided that the above
    copyright notice and this paragraph and the following two
    paragraphs appear in all copies.</P>

    <p>IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY
    PARTY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
    DAMAGES, INCLUDING LOST PROFITS, ARISING OUT OF THE USE OF THIS
    SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
    CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</P>

    <p>THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
    WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
    OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
    SOFTWARE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE
    UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE,
    SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.</P>

    <p>Bei der obigen Lizenz handelt es sich um die BSD-Lizenz, die klassiche
    Open-Source-Lizenz. Sie schränkt die Verwendung des Quellcodes in
    keine Weise ein. Wir mögen diese Lizenz und haben nicht vor, sie
    zu ändern.</p>

    <p>Es gilt die Copyright-Klausel im Original!</p>

    <h4><a name="1.3">1.3</a>)	Auf welchen Unix-Plattformen läuft PostgreSQL?</h4>
    <p>Normalerweise kann PostgreSQL auf jeder modernen UNIX-kompatiblen
    Plattform eingesetzt werden. Diejenigen Plattformen, die bei der
    jeweiligen Versionsfreigabe getestet wurden, sind in den Installations-
    Anleitungen aufgelistet.</p>

    <h4><a name="1.4">1.4</a>)	Welche Nicht-Unix-Portierungen sind verfügbar?</h4>

    <p>Ab Version 8.0 läuft PostgreSQL auf Microsoft NT-basierten Betriebssystemen
    wie Windows 2000, XP und Server 2003. Ein vorgefertigtes Installationspaket
    (derzeit noch im Beta-Stadium) kann von <a href="http://pgfoundry.org/projects/pginstaller">http://pgfoundry.org/projects/pginstaller</a>
    heruntergeladen werden. Einen Überblick über den aktuellen Stand bietet die Win32-FAQ:
    <a href="http://pginstaller.projects.postgresql.org/FAQ_windows.html">http://pginstaller.projects.postgresql.org/FAQ_windows.html</a>.</p>

    <p>Unter Windows 95/98/ME ist es nur möglich, den Datenbankserver mit Hilfe
    der Cygwin-Umgebung (Unix-Portierungsbibliotheken) zu betreiben. Weitere 
    Informationen hierzu gibt es in der CYGWIN-FAQ:
    <a href="http://www.postgresql.org/docs/faqs/text/FAQ_CYGWIN">http://www.postgresql.org/docs/faqs/text/FAQ_CYGWIN</a>.</p>

    <p>Eine Portierung für Novell Netware 6 gibt es unter <a href="http://forge.novell.com">http://forge.novell.com</a>.</p>

    <p>Für OS/2 (eComStation) gibt es eine Version hier:
    <a href="http://hobbes.nmsu.edu/cgi-bin/h-search?sh=1&amp;button=Search&amp;key=postgreSQL&amp;stype=all&amp;sort=type&amp;dir=%2F">http://hobbes.nmsu.edu/cgi-bin/h-search?sh=1&amp;button=Search&amp;key=postgreSQL&amp;stype=all&amp;sort=type&amp;dir=%2F</a></p>

    <h4><a name="1.5">1.5</a>) Woher bekomme ich PostgreSQL?</h4>

    <p>Der zentrale FTP-Server für PostgreSQL ist der ftp-Server
    <a href="ftp://ftp.postgresql.org/pub/">ftp://ftp.postgresql.org/pub/</a>. Weitere Mirror-Sites sind auf der
    PostgreSQL-Website aufgelistet.</p>

    <h4><a name="1.6">1.6</a>) Wo bekomme ich Support für PostgreSQL?</h4>

    <p>Die zentrale (englischsprachige) Mailing-Liste ist:
    <a href="mailto:pgsql-general@postgresql.org">mailto:pgsql-general@postgresql.org</a> .</p>

    <p>Die Liste ist Themen vorbehalten, die PostgreSQL betreffen. Die Anmeldung
    erfolgt mit einer Email an die Adresse <a href="mailto:pgsql-general-request@postgresql.org">pgsql-general-request@postgresql.org</a> mit folgenden Zeilen im Text
    (nicht in der Betreffzeile):</p>
<pre>
    subscribe
    end
</pre>
    <p>Es gibt auch eine Digest-Liste (eine Liste, die Mails zusammengefasst
    sendet). Um sich an dieser Digest-Liste anzumelden, senden Sie eine Email
    an <a href="mailto:pgsql-general-digest-request@postgresql.org">pgsql-general-digest-request@postgresql.org</a> mit folgendem Text:</p>
<pre>
    subscribe
    end
</pre>

    <p>Es gibt noch die Bug-Mailingliste. Die Anmeldung für diese Liste erfolgt
    durch eine Email an <a href="mailto:bugs-request@postgresql.org">bugs-request@postgresql.org</a> mit folgendem Text:</p>
<pre>
    subscribe
    end
</pre>

    <p>Die Entwickler-Mailingliste kann mit einer Email an
    <a href="mailto:pgsql-hackers-request@postgresql.org">pgsql-hackers-request@postgresql.org</a> abonniert werden. Die Email muß ebenfalls folgenden Text enthalten:</p>
<pre>
    subscribe
    end
</pre>

    <p>Eine deutschsprachige Mailing-Liste gibt es ebenfalls:
    <a href="http://archives.postgresql.org/pgsql-de-allgemein/">http://archives.postgresql.org/pgsql-de-allgemein/</a>;
    die Liste kann <a href="http://mail.postgresql.org/mj/mj_wwwusr?domain=postgresql.org&amp;func=lists-long-full&amp;extra=pgsql-de-allgemein">hier</a> abonniert werden.</p>

    <p>Weitere Mailinglisten und Informationen zu PostgreSQL befinden sich auf der PostgreSQL-Homepage:</p>
<blockquote>
<p><a href="http://www.postgresql.org">http://www.postgresql.org</a></p>
</blockquote>
    <p>Es gibt außerdem einen IRC-Channel bei EFNet und bei Freenode, Channel
    <em>#PostgreSQL</em>. Unter UNIX/Linux können Sie mit z.B.
    <small>irc -c '#PostgreSQL' "$USER" irc.freenode.net.</small> bzw.
    <small>irc -c '#PostgreSQL' "$USER" irc.phoenix.net</small> daran teilnehmen.</p>

    <p>Eine Liste von Unternehmen, die Support für PostgreSQL auf kommerzieller
    Basis leisten, kann unter
      <a href="http://techdocs.postgresql.org/companies.php">http://techdocs.postgresql.org/companies.php</a>
    eingesehen werden.</p>

    <h4><a name="1.7">1.7</a>) Was ist die neueste Version von PostgreSQL?</h4>

    <p>Die neueste Version von PostgreSQL ist 8.0.0 .</p>

    <p>Die Freigabe einer neuen Version erfolgt im Schnitt alle 6 bis 8 Monaten.</p>

    <h4><a name="1.8">1.8</a>) Welche Dokumentation ist für PostgreSQL verfügbar?</h4>

    <p>Einige Handbücher, Man-Pages und einige kleine Testprogramme sind in
    der Distribution enthalten. Siehe das <em>/doc</em>-Verzeichnis. Ausserdem sind
    alle Handbücher online unter <a href="http://www.postgresql.org/docs/">http://www.postgresql.org/docs/</a>
    verfügbar.</p>

    <p>Zwei Bücher zu PostgreSQL sind online verfügbar unter
    <a href="http://www.postgresql.org/docs/awbook.html">http://www.postgresql.org/docs/awbook.html</a> und
    <a href="http://www.commandprompt.com/ppbook/">http://www.commandprompt.com/ppbook/</a> .</p>

    <p>Eine Liste lieferbarer PostgreSQL-Bücher befindet sich unter
      <a href="http://techdocs.postgresql.org/techdocs/bookreviews.php">http://techdocs.postgresql.org/techdocs/bookreviews.php</a>
    Diverse technische Artikel befinden sich unter
      <a href="http://techdocs.postgresql.org/">http://techdocs.postgresql.org/</a> .</p>

    <p><em>psql</em> hat einige nützliche <em>\d</em>-Befehle, um Informationen über Typen,
    Operatoren, Funktionen, Aggregate, usw. zu zeigen. </p>

    <h4><a name="1.9">1.9</a>) Wie erfahre ich von bekannten Bugs oder fehlenden Features?</h4>

    <p>PostgreSQL unterstützt eine erweiterte Teilmenge von SQL-92. Siehe
    unsere TODO-Liste unter <a href="http://www.postgresql.org/docs/faqs.TODO.html">http://www.postgresql.org/docs/faqs.TODO.html</a> für eine Auflistung 
    der bekannten Bugs, fehlenden Features und zukünftigen Pläne.</p>

    <h4><a name="1.10">1.10</a>) Wie kann ich <small>SQL</small> lernen?</h4>
   
    <p>Das PostgreSQL Book auf <a href="http://www.postgresql.org/docs/awbook.html">http://www.postgresql.org/docs/awbook.html</a> bietet
    eine Einführung in SQL. Ein weiteres PostgreSQL-Buch befindet sich unter
    <a href="http://www.commandprompt.com/ppbook">http://www.commandprompt.com/ppbook</a> . Es gibt zudem nette Tutorials unter
    <a href="http://www.intermedia.net/support/sql/sqltut.shtm">http://www.intermedia.net/support/sql/sqltut.shtm</a> ,
    <a href="http://ourworld.compuserve.com/homepages/graeme_birchall/HTM_COOK.HTM">http://ourworld.compuserve.com/homepages/graeme_birchall/HTM_COOK.HTM</a>
    und <a href="http://sqlcourse.com">http://sqlcourse.com</a> .</p>

    <p>Eine weitere Empfehlung ist "Teach Yourself SQL in 21 Days, Second Edition",
    es ist unter <a href="http://members.tripod.com/er4ebus/sql/index.htm">http://members.tripod.com/er4ebus/sql/index.htm</a> erhältlich.</p>

    <p>Viele PostgreSQL-Anwender mögen "The Practical SQL Handbook" (Bowman
    et al., Addison Wesley). Andere dagegen mögen "The Complete Reference SQL"
    (Groff et al., McGraw-Hill).</p>

    <h4><a name="1.11">1.11</a>) Ist PostgreSQL Y2K (Jahr 2000) fähig?</h4>

    <p>Ja, wir können Datumsangaben nach dem Jahr 2000 n.Chr. und vor 2000 v.Chr. leicht
    verarbeiten.</p>

    <h4><a name="1.12">1.12</a>)	Wie kann ich im Entwicklerteam mitarbeiten?</h4>

    <p>Zuerst laden Sie die neuesten Quellen herunter und lesen Sie die
    PostgreSQL-Entwicklerunterlagen auf unserer Website oder in der
    Distribution. Dann melden Sie sich zu den Entwickler-Mailinglisten
    <em>pgsql-hackers</em> und <em>pgsql-patches</em> an. Anschließend senden Sie qualitativ
    hochwertige Patches an die <em>pgsql-patches</em> Mailingliste.</p>

    <p>Es gibt ungefähr ein Dutzend Leute, die das <em>commit</em>-Recht im
    PostgreSQL <small>CVS</small>-Archiv haben. Alle haben derart viele hochwertige Patches
    eingebracht, dass es für die <small>CVS</small>-Verwalter schwer war, mitzuhalten. Und
    wir hatten Vertrauen, dass die von ihnen festgelegten Änderungen aller
    Wahrscheinlichkeit nach von hoher Qualität sind.</p>

    <h4><a name="1.13">1.13</a>) Wie sende ich einen Fehlerbericht?</h4>

    <p>Bitte besuchen Sie die PostgreSQL-BugTool-Seite <a href="http://www.postgresql.org/support/submitbug">http://www.postgresql.org/support/submitbug</a>,
    die Hinweise und Anleitungen zur Einreichung von Fehlerberichten enthält.</p>

    <p>Überprüfe auch den ftp-Server <a href="ftp://ftp.postgresql.org/pub/">ftp://ftp.postgresql.org/pub/</a>,
    um nachzusehen, ob es eine neuere PostgreSQL-Version oder neue Patches gibt.</p>

    <h4><a name="1.14">1.14</a>) Wie läuft PostgreSQL im Vergleich zu anderen Datenbanksystemen?</h4>

    <p>Es gibt verschiedene Methoden, Software zu messen: Eigenschaften,
    Performanz, Zuverlässigkeit, Support und Preis.</p>

    <dl>
      <dt><b>Eigenschaften</b></dt>
      <dd><p>PostgreSQL besitt die meisten Eigenschaften - wie Transaktionen,
          Unterabfragen (Subqueries), Trigger, Views und verfeinertes Locking -
          die bei großen kommerziellen DBMS vorhanden sind. Es bietet außerdem
          einige anderen Eigenschaften, die diese nicht immer haben, wie
          benutzerbestimmte Typen, Vererbung, Regeln, und die 
          Multi-Versionen-Steuerung zum Verringern konkurrierender Locks.</p>
      </dd>

      <dt><b>Performanz</b></dt>
      <dd><p>PostgreSQL weist eine Performanz auf, die mit der von kommerziellen
          und anderen Open-Source-Datenbanken vergleichbar ist. In
          manchen Bereichen ist es schneller, in anderen langsamer.</p>
          <p>Im Vergleich zu MySQL oder abgespeckten Datenbank-Systemen 
          ist PostgreSQL in Lastsituationen - z.B. bei zeitgleichen
          Zugriffen durch mehrere Nutzer, bei komplexen Abfragen oder gleichzeitigen
          Lese- und Schreibzugriffen schneller. MySQL ist nur bei einfacheren
          SELECT-Abfragen mit wenigen Nutzern im Vorteil. MySQL besitzt allerdings 
          nur wenige der im Punkt "Eigenschaften" genannten Features. PostgreSQL setzt auf 
          Zuverlässigkeit und Funktionsumfang, dabei wird selbstredend ständig 
          an Performanz-Verbesserungen gearbeitet. </p>
      </dd>

      <dt><b>Zuverlässigkeit</b></dt>
      <dd><p>Es ist selbstredend, dass ein DBMS wertlos ist, wenn es nicht
          zuverlässig arbeitet. Daher bemühen wir uns, nur streng geprüften und
          beständigen Code freizugeben, der nur ein Minimum an Programmfehlern
          aufweist. Jede Freigabe hat mindestens einen Monat Betatest-Phase
          hinter sich, und unsere Freigabehistorie beweist, dass wir stabile und
          solide Versionen freigeben, die im Produktionsbetrieb genutzt werden
          können. Wir glauben, dass wir im Vergleich mit anderer
          Datenbanksoftware vorteilhaft dastehen.</p>
      </dd>

      <dt><b>Support</b></dt>
      <dd><p>Unsere Mailinglisten bieten die Möglichkeit, gemeinsam mit einer
          großen Gruppe von Entwicklern und Benutzern mögliche Probleme
          zu lösen. Wir können nicht immer eine Fehlerbehebung
          garantieren, kommerzielle DBMS tun dies aber auch nicht.
          Der direkte Kontakt zur Entwickler- und Benutzergemeinschaft und der
          Zugriff auf die Handbücher und den Quellcode ermöglicht einen
          im Vergleich zu anderen DBMS höherwertigeren Support. Es gibt jedoch auch
          Anbieter von kommerziellen Support-Leistungen (siehe FAQ-Punkt <a href="#1.6">1.6</a>).</p>
      </dd>
      <dt><b>Preis</b></dt>
      <dd><p>PostgreSQL ist frei verfügbar, sowohl für die kommerzielle wie
          auch für die nicht-kommerzielle Nutzung. Sie können den PostgreSQL-Code
          ohne Einschränkungen (außer denjenigen, die in der oben angegebene
          BSD-artigen Lizenz erwähnt werden) in Ihr Produkt integrieren.</p>
      </dd>
    </dl>

    <h4><a name="1.15">1.15</a>) Wie kann ich PostgreSQL finanziell unterstützen?</h4>

    <p>PostgreSQL hat seit dem Anfang in 1996 eine exzellente Infrastruktur.
    Dies ist Marc Fournier zu verdanken, der sie über die Jahre
    hinweg geschaffen und gepflegt hat.</p>

    <p>Eine hochwertige Infrastruktur ist für ein Open-Source-Projekt wie dieses
    sehr wichtig. Sie verhindert Probleme und Verzögerungen beim Fortschritt des
    Projekts.</p>

    <p>Selbstverständlich ist diese Infrastruktur nicht billig. Es gibt eine
    Reihe von einmaligen und monatlich anfallenden Kosten, die für
    den Betrieb beglichen werden müssen. Falls Sie oder Ihre Firma
    dazu finanziell beitragen können, besuchen Sie bitte die URL
      <a href="http://store.pgsql.com/shopping/">http://store.pgsql.com/shopping/</a>
    wo Sie eine Spende abgeben können.</p>

    <p>Obwohl diese Web-Seite das Unternehmen "PostgreSQL, Inc." erwähnt, ist
    der Bereich "contributions" (Beiträge) ausschliesslich für die
    Unterstützung des PostgreSQL-Projekts da und nicht für die Finanzierung
    einer bestimmten Firma. Sie können auch gerne einen finanziellen Beitrag
    an die Kontaktadresse verschicken.</p>

    <p>Eine Möglichkeit der nicht-finanziellen Untetstützung besteht übrigens
    darin, für <a href="http://advocacy.postgresql.org">http://advocacy.postgresql.org</a> (en.) bzw. <a href="http://advocacy.postgresql.org/?lang=de">http://advocacy.postgresql.org/?lang=de</a> (dt.)
    einen Bericht über den erfolgreichen Einsatz von PostgreSQL in Ihrem 
    Unternehmen oder in Ihrer Organisation bereitzustellen.</p>

    <hr />

    <h2 align="center">Fragen zu Benutzerprogrammen</h2>

    <h4><a name="2.1">2.1</a>) Gibt es ODBC-Treiber für PostgreSQL?</h4>

    <p>Es sind zwei ODBC-Treiber verfügbar: PsqlODBC und OpenLink ODBC.</p>

    <p>PsqlODBC kann von <a href="http://gborg.postgresql.org/project/psqlodbc/projdisplay.php">http://gborg.postgresql.org/project/psqlodbc/projdisplay.php</a>
    heruntergeladen werden.</p>

    <p>OpenLink ODBC kann unter <a href="http://www.openlinksw.com/">http://www.openlinksw.com</a> bezogen werden. Die
    Software arbeitet mit dem Standard-ODBC-Client dieser Firma, so dass
    PostgreSQL-ODBC auf jeder Client-Plattform zur Verfügung steht, die
    unterstützt wird (Win, Mac, Unix, VMS).</p>

    <p>OpenLink wird dieses Produkt wahrscheinlich an Leute verkaufen, die
    kommerziellen Support benötigen, dennoch wird immer eine
    Freeware-Version verfügbar sein. Fragen dazu bitte an
    <a href="mailto:postgres95@openlink.co.uk">postgres95@openlink.co.uk</a>. </p>

    <h4><a name="2.2">2.2</a>) Welche Werkzeuge gibt es, um Web-Seiten mit PostgreSQL zu
    verbinden?</h4>

    <p>Eine nette Einführung zu datenbank-gestützten Webseiten kann unter
    <a href="http://www.webreview.com"> http://www.webreview.com</a> (engl.) abgerufen werden.</p>

    <p>Für die Web-Integration ist PHP eine ausgezeichnete Schnittstelle.
    PHP gibt es bei <a href="http://www.php.net">http://www.php.net</a></p>

    <p>Für komplexere Aufgaben bietet sich die Perl-Schnittstelle mit CGI.pm
    oder mod_perl.</p>

    <h4><a name="2.3">2.3</a>) Hat PostgreSQL eine grafische Benutzerschnittstelle?</h4>
   
    <p>Es gibt mehrere grafische Schnittstellen für PostgreSQL, darunter
    PgAccess ( <a href="http://www.pgaccess.org">http://www.pgaccess.org</a>), 
    pgAdmin III (<a
    href="http://www.pgadmin.org">http://www.pgadmin.org</a>, RHDB Admin (<a
    href="http://sources.redhat.com/rhdb/">http://sources.redhat.com/rhdb/
    </a>) und Rekall (<a href="http://www.thekompany.com/products/rekall/">
    http://www.thekompany.com/products/rekall/</a>, GPL/proprietär). Es gibt 
    außerdem phpPgAdmin (<a href="http://phppgadmin.sourceforge.net/">
    http://phppgadmin.sourceforge.net/ </a>), eine web-basierte Schnittstelle. </p>

    <h4><a name="2.4">2.4</a>) Welche Programmiersprachen und Schnittstellen gibt es?</h4>

    <p>Die meisten gängigen Programmiersprachen bieten Schnittstellen für
    PostgreSQL.
    </p>
    <p>Die folgenden Schnittstellen werden mit der PostgreSQL-Distribution 
    ausgeliefert:</p>
    <ul>
      <li>C (libpq)</li>

      <li>Embedded C (ecpg)</li>

      <li>Java (jdbc)</li>

      <li>Python (PyGreSQL)</li>

      <li>TCL (libpgtcl)</li>
    </ul>
    <p>Weitere Schnittstellen für andere Sprachen können über 
    <a href="http://gborg.postgresql.org">http://gborg.postgresql.org</a>
    (Bereich <em>Drivers/Interfaces</em>) bezogen werden.
    </p>
    <hr />
    <h2 align="center">Administrative Fragen</h2>

    <h4><a name="3.1">3.1</a>) Wie installiere ich PostgreSQL woanders als in /usr/local/pgsql?</h4>

    <p>Bei der Ausführung von <em>configure</em> die Option <em>--prefix</em> mit dem Zielverzeichnis
    angeben.</p>

    <h4><a name="3.2">3.2</a>)  Wenn ich den <em>postmaster</em> starte, erhalte ich einen Nachricht
    "Bad System Call" bzw. "core dumped". Wieso?</h4>

    <p>Das kann verschiedene Ursachen haben. Überprüfen Sie zuerst, ob Ihr Kernel
    System V Extensions unterstützt. PostgreSQL benötigt Kernel-Unterstützung
    für Shared Memory und Semaphoren.</p>

    <h4><a name="3.3">3.3</a>) Wenn ich versuche, den <em>postmaster</em> zu starten, bekomme ich <em>"IpcMemoryCreate"</em>-Fehlermeldungen. Warum?</h4>

    <p>Entweder ist Shared Memory in Ihrem Kernel nicht korrekt konfiguriert, oder
    Sie müssen den Shared Memory Bereich vergrößern. Die genaue Größe hängt
    von Ihrer Systemarchitektur und von der Anzahl der Puffer und Serverprozesse
    ab, die Sie für <em>postmaster</em> konfiguriert haben. Bei den voreingestellten
    Werten für Puffer und Prozesse benötigen Sie bei den meisten Systemen
    ein Minimum von ca. 1 MB. Der "PostgreSQL Administrator's Guide"
    (<a href="http://www.postgresql.org/docs/current/static/kernel-resources.html">http://www.postgresql.org/docs/current/static/kernel-resources.html</a>)
    enthält weitere Informationen zu Shared Memory und Semaphores.</p>


    <h4><a name="3.4">3.4</a>) Wenn ich versuche, den <em>postmaster</em> zu starten, bekomme ich
    "<em>IpcSemaphoreCreate</em>"-Fehlermeldungen. Warum?</h4>

    <p>Falls die Fehlermeldung "<em>IpcSemaphoreCreate: semget failed (No space
    left on device)</em>" lautet, ist Ihr Kernel mit zu wenig Semaphoren
    konfiguriert. PostgreSQL benötigt eine Semaphore pro möglichem
    Backend-Prozess. Eine Zwischenlösung wäre, <em>postmaster</em> mit einer
    geringeren Anzahl an Backend-Prozessen zu starten. Benutzen Sie dazu die
    <em>-N</em> Option mit einem kleineren Wert als die standardmäßigen 32. Eine
    dauerhafte Lösung wäre es, die Parameter <small>SEMMNS</small> und <small>SEMMNI</small> Ihres Kernels
    zu erhöhen.</p>

    <p>Nichtfunktionierende Semaphores können außerdem bei hoher Datenbanklast
    zu Abstürzen führen.</p>

    <p>Falls die Fehlermeldung anders aussieht, ist möglicherweise keine
    Semaphoren-Unterstützung in Ihrem Kernel aktiviert. Der "<em>PostgreSQL
    Administrator's Guide</em>" <!--(<a href=""></a>)-->enthält weitere Informationen zu Shared Memory
    und Semaphores.</p>


    <h4><a name="3.5">3.5</a>) Wie regle ich Zugriffe von anderen Rechnern?</h4>

    <p>PostgreSQL ist standardmäßig so eingestellt, dass Verbindungen nur vom
    lokalen Rechner über Unix Domain Sockets möglich sind. Verbindungen
    von anderen Rechnern über TCP/IP sind nur möglich, wenn der <em>postmaster</em>
    mit der <em>-i</em> Option gestartet wird und / oder die Option <tt>listen_addresses</tt>
    (in 7.x-Versionen: <tt>tcpip_sockets</tt>) in postgresql.conf eingeschaltet wird, und die 
    host-basierte Authentifizierung in der Datei <em>$PGDATA/pg_hba.conf</em> 
    entsprechend angepasst ist.</p>

    <h4><a name="3.6">3.6</a>) Wie optimiere ich die Datenbank für bessere Leistung?</h4>

    <p>Der Einsatz von Indizes sollte auf jeden Fall Abfragen beschleunigen. Die
    Anweisung <small>EXPLAIN ANALYZE</small> zeigt, wie PostgreSQL Abfragen interpretiert und 
    welche Indizes benutzt werden.</p>

    <p>Wenn Sie eine große Anzahl von <small>INSERT</small>-Anweisungen durchführen, sollten Sie
    überlegen, ob die Durchführung mit der <small>COPY</small>-Anweisung in Frage kommt. Dies
    funktioniert wesentlich schneller als einzelne <small>INSERT</small>-Befehle.
    SQL-Anweisungen, die sich nicht in einem <small>BEGIN WORK</small>/<small>COMMIT</small> Transaktions-
    Block befinden, werden als eigene Transaktionen behandelt. Überlegen Sie,
    ob die Anweisungen nicht in einen einzelnen Transaktionsblock zusammen-
    gefasst werden können. Das reduziert den Transaktionsaufwand. Überlegen
    Sie auch, bei größeren Datenänderungen Indizes zu löschen und danach
    wiederherzustellen.</p>

    <p>Es gibt verschiedene Tuning-Optionen, die im Handbuch dokumentiert sind 
    (<a href="http://www.postgresql.org/docs/current/static/runtime.html">Administration Guide/Server Run-time Environment/Run-time Configuration</a>).
    Sie können <em>fsync()</em> ausschalten, indem Sie beim Starten des <em>postmaster</em> 
    die Optionen <em>-o -F</em> angeben. Das hindert <em>fsync()</em>-Operationen 
    daran, nach jeder Transaktion die Daten direkt auf die Festplatte zu schreiben.</p>

    <p>Sie können auch mit der <em>shared_buffers</em> Option des <em>postmaster</em> die 
    Anzahl der Shared Memory Puffer für die Backend-Prozesse erhöhen. Falls Sie diesen Wert
    jedoch zu hoch setzen, kann es vorkommen, dass der <em>postmaster</em> nicht startet,
    weil die Obergrenze der Speicherzuweisung für Shared Memory überschritten
    wird. Jeder Puffer ist 8 kB groß, voreingestellt sind 1000 Puffer.</p>

    <p>Die <em>sort_mem</em> (ab PostgreSQL 8.0: <em>work_mem</em>)-Optionen des Backends können benutzt 
    werden, um die Größe des Speicherplatzes für temporäres Sortieren zu erhöhen. Die
    Werte werden in Kilobyte gemessen und sind standardmäßig auf 1024 (d.h. 1MB) festgelegt.</p>

    <p>Die <small>CLUSTER</small>-Anweisung kann benutzt werden, um Daten in
    Basistabellen zu gruppieren, so dass - um einen schnelleren Zugriff zu
    erreichen - die physikalische Speicherung der Reihenfolge eines der Indexe
    entspricht.  Siehe auch die <small>CLUSTER(l)</small> Man-Page für weitere
    Details.</p>

    <h4><a name="3.7">3.7</a>)	Welche Debugging-Funktionen sind für PostgreSQL verfügbar?</h4>

    <p>PostgreSQL hat einige Möglichkeiten, Statusinformationen anzuzeigen,
    die bei der Fehlersuche nützlich sein können.</p>
    
    <p>Wenn Sie PostgreSQL mit dem <em>--enable-cassert</em> Option kompiliert
    haben, verfolgen zahlreiche <em>assert()</em>-Anweisungen den Ablauf des
    Backends und halten das Programm an, wenn etwas Unerwartetes passiert.</p>

    <p>Sowohl der <em>postmaster</em> als auch <em>postgres</em> stellen mehrere
    Debug-Optionen zur Verfügung. Zuerst sollten Sie sichergehen, dass Sie die Ausgaben über den Standard-Output
    und den Standard-Error in eine Datei umleiten, wenn Sie den <em>postmaster</em> starten:</p>
<pre>
      cd /usr/local/pgsql
      ./bin/postmaster &gt;server.log 2&gt;&amp;1 &amp;
</pre>

    <p>Dadurch wird die Datei <em>server.log</em> im PostgreSQL-Verzeichnis erzeugt. Diese
    Datei enthält nützliche Informationen über Probleme oder Fehler, die
    im Server aufgetreten sind. <em>postmaster</em> hat eine <em>-d</em> Option, die noch
    detailliertere Informationen liefert. Zur <em>-d</em> Option wird eine Nummer
    angegeben, die den Debug-Level - also die Menge der berichteten
    Information - angibt. Achtung, hohe Debug-Levels erzeugen schnell große
    Logdateien!</p>

    <p>Wenn der <em>postmaster</em> nicht läuft, können Sie das <em>postgres</em>-Backend sogar
    von der Befehlszeile ausführen und eine <small>SQL</small>-Anweisung direkt eingeben.
    Dies ist allerdings <em>nur</em> für Debugging-Zwecke zu empfehlen. Beachten Sie, dass hierbei ein
    Zeilenumbruch, und nicht - wie sonst üblich - das Semikolon die <small>SQL</small>-Anweisung beendet.
    Falls Sie PostgreSQL mit Debugging-Symbolen kompiliert haben, können Sie
    mit einem Debugger sehen, was passiert. Da das Backend jedoch nicht vom
    <em>postmaster</em> gestartet wurde, läuft es nicht in der gleichen
    Umgebung und deshalb können einige locking-Vorgänge sowie die Kommunikation zwischen den Backends nicht
    reproduziert werden.</p>

    <p>Wenn der <em>postmaster</em> hingegen läuft, führen Sie <em>psql</em> in einem Fenster aus,
    ermitteln Sie die Prozessnummer (<small>PID</small>) des <em>postgres</em>-Prozesses, der von <em>psql</em>
    verwendet wird (mit <code>SELECT pg_backend_pid()</code>). Binden Sie einen Debugger an diese <small>PID</small>
    und führen Sie Abfragen von <em>psql</em> aus. Wenn Sie den postgres-Serverstart analysieren 
    wollen, setzen Sie die Umgebungsvariable <em>PGOPTIONS="-W </em>n<em>"</em>, und starten Sie 
    dann <em>psql</em>. Dies verzögert den Start um <em>n</em> Sekunden, damit Sie einen Debugger an
    den Prozess binden und ggf. Breakpoints setzen können, bevor die
    Startsequenz begonnen wird.</p>

    <p>Es gibt verschiedene Einstellungen (die <small>log_*</small>-Gruppe), die diverse
    Server-Statistik ausgeben und daher bei der Fehlersuche und Performanzmessung sehr
    nützlich sein können.</p>

    <p>Sie können die Anwendung auch mit Profiling kompilieren, um zu sehen,
    welche Funktionen wieviel Ausführungszeit beanspruchen. Das Backend
    Profil wird im Verzeichnis <em>pgsql/data/base/dbname</em> abgelegt. Das
    Client-Profil wird in das aktuelle Verzeichnis abgelegt. Bitte beachtern Sie, 
    dass unter Linux PostgreSQL mit der Option <em>-DLINUX_PROFILE</em> kompiliert werden
    muß, um Profiling nutzen zu können.</p>

    <h4><a name="3.8">3.8</a>) Ich bekomme die Meldung "<em>Sorry, too many clients</em>", wenn ich eine 
    Verbindung aufzubauen versuche. Warum?</h4>
   
    <p>Sie müssen die maximale Anzahl der gleichzeitig ausführbaren Backend-
    Prozesse hochsetzen.</p>

    <p>Die Voreinstellung erlaubt 32 Prozesse. Sie können diese erhöhen, indem Sie
    den <em>postmaster</em> mit einem entsprechenden <em>-N</em> Parameter starten bzw. die
    Konfigurationsdatei <em>postgresql.conf</em> anpassen.</p>

    <p>Bitte beachten Sie, dass Sie auch <em>-B</em> auf ein Wert größer als die Voreinstellung
    von 64 setzen müssen, wenn Sie <em>-N</em>  auf einen Wert höher als 32 setzen;
    <em>-B</em> muss mindestens das Doppelte von <em>-N</em> betragen, und einer besseren
    Performanz wegen sollte der Wert noch höher sein. Bei einer hohen Anzahl von
    Backend-Prozessen kann es vorkommen, dass Sie einige Unix-Kernel-
    Parameter ebenfalls erhöhen müssen. Folgende Parameter sind zu überprüfen:
    die Maximalgröße der Shared Memory Blocks <small>SHMMAX</small>; die Maximalanzahl der
    Semaphoren <small>SEMMNS</small> und <small>SEMMNI</small>; die maximale Anzahl von Prozessen NPROC;
    die maximale Anzahl von Prozessen pro User MAXUPRC; und die Maximalzahl
    der geöffneten Dateien <small>NFILE</small> und <small>NINODE</small>.  Durch die Begrenzung der Anzahl
    erlaubter Backend-Prozesse wird verhindert, dass System-Ressourcen
    durch PostgreSQL aufgebraucht werden.</p>

    <h4><a name="3.9">3.9</a>) Was befindet sich im Verzeichnis <em>pgsql_tmp/</em>?</h4>

    <p>Dieses Verzeichnis enthält temporäre Dateien, die durch den <em>query executor</em>
    erzeugt werden. Wenn zum Beispiel eine Sortierung durchgeführt werden muß,
    um ein <small>ORDER BY</small> auszuführen, und diese Sortierung mehr Hauptspeicher
    benötigt, als mit dem Backend-Parameter <em>-S</em> erlaubt wurde, dann werden
    diese Dateien erzeugt, um die Daten dort zu auszulagern.</p>

    <p>Die temporären Dateien sollten automatisch gelöscht werden. Falls das
    Backend jedoch während einer Sortierung abstürzen sollte, bleiben sie
    erhalten. Nach einem Neustart des <em>postmaster</em> werden sie dann aber wieder
    automatisch gelöscht.</p>

    <h4><a name="3.10">3.10</a>) Warum muß ich bei jeder neuen Hauptversion von PostgreSQL
    die komplette Datenbank exportieren und anschließend reimportieren?</h4>

    <p>Zwischen "kleinen" PostgreSQL-Versionsänderungen (z.B. zwischen
    7.2 und 7.2.1) werden keine strukturellen Änderungen durchgeführt,
    wodurch ein erneutes Aus- und Einlesen der Daten nicht erforderlich ist.
    Allerdings wird bei "großen" Versionsänderungen (z.B. zwischen 7.2 und 7.3)
    oft das interne Format der Systemtabellen und Datendateien
    angepasst. Diese Änderungen sind oft sehr komplex, wodurch die
    Rückwärtskompatibilität der Datendateien nicht gewährleistet werden kann.
    Durch das Exportieren werden die Daten in einem generischen Format
    ausgegeben, wodurch die Importierung in das neue interne Format
    ermöglicht wird.</p>

    <p>Bei Upgrades, bei denen keine Formatänderungen stattgefunden haben,
    kann das <em>pg_upgrade</em>-Skript benutzt werden, um die Daten ohne Aus- 
    und Einlesen zu übertragen. Die jeweilige Dokumentation gibt an, ob für
    die betreffende Version <em>pg_upgrade</em> verfügbar ist.</p>


    <h4><a name="3.11">3.11</a>) Welche Hardware eignet sich für den Betrieb mit PostgreSQL?</h4>

    <p>PostgreSQL läuft auf fast jeder Hardware-Kombination. Im PC-Bereich
    gibt es allerdings sehr große Abweichungen in der Qualität. Für einen
    Arbeitsplatz- oder Entwicklungsrechner mag dies nicht so bedeutend sein,
    im Server-Betrieb jedoch lohnt sich auf jeden Fall die Investition
    in teurere Bestandteile (Stichwörter ECC-Speicher, SCSI, Hauptplatinen
    und Netzteile von namhaften Herstellern).
    </p>

    <hr />

    <h2 align="center">Fragen zum Betrieb</h2>

    <h4><a name="4.1">4.1</a>) Worin besteht der Unterschied zwischen Binary Cursors und Normal
    Cursors?</h4>

    <p>Vgl. die <small>DECLARE</small> Man-Page für eine Beschreibung.</p>

    <h4><a name="4.2">4.2</a>) Wie wähle ich per <small>SELECT</small>-Anweisung nur die ersten paar
    Zeilen bzw. eine beliebige Zeile in einer Abfrage aus?</h4>

    <p>Vgl. die <small>FETCH</small> Man-Page, oder benutzen Sie <small>SELECT ... LIMIT...</small> .</p>

    <p>Selbst wenn Sie nur die ersten paar Zeilen einer Tabelle abfragen möchten,
    muß unter Umständen die komplette Abfrage abgearbeitet werden. Ziehen Sie also
    möglichst eine Abfrage in Erwägung, die eine <small>ORDER BY</small>-Anweisung
    benutzt, welche wiederum auf indizierte Spalten verweist. In diesem Fall kann
    PostgreSQL direkt nach den gewünschten Zeilen suchen und braucht nicht
    jede mögliche Ergebniszeile abzuarbeiten.</p>

    <p>Bitte beachten Sie, dass mit PostgreSQL 7.3 die Syntax <small>LIMIT <em>n</em>, <em>m</em></small>
    durch <small>LIMIT <em>n</em> OFFSET <em>m</em></small> ersetzt wurde.</p>

    <p>Um eine beliebige Zeile auszuwählen, nutzen Sie <small>ORDER BY random()</small>:</p>
   <pre>
       SELECT spalte
         FROM tabelle
     ORDER BY random()
        LIMIT 1
   </pre>

    <h4><a name="4.3">4.3</a>) Wie finde ich heraus, welche Tabellen, Indizes, Datenbanken oder 
    Benutzer in der Datenbank definiert sind? Wie bekomme ich die von <em>psql</em> verwendeten Abfragen?</h4>

    <p>In psql zeigt der Befehl \dt eine Liste der Datenbanktabellen. Weitere psql-Befehle
    lassen sich mit \? anzeigen. Sie können sich die Datei <em>pgsql/src/bin/psql/describe.c</em> 
    mit dem Quellcode für <em>psql</em> ansehen. Sie enthält die <small>SQL</small>-Abfragen, die die
    Backslash-Kommandos (\) ausführen. Sie können <em>psql</em> auch mit der <em>-E</em>
    Option starten. Danach gibt <em>psql</em> die Abfragen aus, die es bei der Ausführung der Befehle
    benutzt. Außerdem biete PostgreSQL ein <small>SQL</small>-kompatibles INFORMATION SCHEMA,
    das Metainformation über die Datenbank zur Verfügung stellt.</p>

    <p>Die Datei <em>pgsql/src/tutorial/syscat.source</em> enthält außerdem viele <small>SELECT</small>-
    Abfragen, mit deren Hilfe man Information über die Systemtabellen erhalten kann.</p>

    <h4><a name="4.4">4.4</a>) Wie entferne ich eine Spalte aus einer Tabelle? Wie ändere 
    ich den Datentyp einer Spalte?</h4>

    <p>Der Syntax <small>ALTER TABLE DROP COLUMN</small> wird ab PostgreSQL 7.3 unterstützt.</p>

    <p>Bei früheren Versionen bietet das folgende Verfahren Ersatz:</p>
<pre>
      BEGIN;
      LOCK TABLE old_table;
      SELECT ...  -- alle außer der zu entfernenden Spalte hier auswählen
        INTO TABLE new_table
        FROM old_table;
      DROP TABLE old_table;
      ALTER TABLE new_table RENAME TO old_table;
      COMMIT;
</pre>
     <p>Um den Datentyp einer Spalte zu ändern, gehen Sie wie folgt vor:</p>
     <pre>
       BEGIN;
       ALTER TABLE <em>tabelle</em> ADD COLUMN <em>neue_spalte</em> <em>neuer_datentyp</em>;
       UPDATE <em>tabelle</em> SET <em>neue_spalte</em> = CAST(<em>alte_spalte</em> AS <em>neuer_datentyp</em>);
       ALTER TABLE <em>tabelle</em> DROP COLUMN <em>alte_spalte</em>;
       COMMIT;
    </pre>
    <p>Um den Speicherplatz freizugeben, der von der gelöschten Spalte verwendet 
    wurde, führen Sie <small>VACUUM FULL</small> aus.</p>

    <h4><a name="4.5">4.5</a>) Was ist die Maximalgröße für eine Zeile, eine Tabelle, eine Datenbank?</h4>

    <p>Es bestehen folgende Obergrenzen:</p>
<pre>
    Maximale Größe eine Datenbank?           unbeschränkt (es existieren
                                               Datenbanken mit 32 TB)
    Maximale Größe einer Tabelle?            32 TB
    Maximale Größe einer Zeile?              1,6 TB
    Maximale Größe einer Spalte?             1 GB
    Maximale Anzahl von Zeilen in einer Tabelle?
                                             unbeschränkt
    Maximale Anzahl von Spalten in einer Tabelle?
                                             250-1600 je nach Spaltentyp
    Maximale Anzahl von Indizies für eine Tabelle?
                                             unbeschränkt
</pre>
    <p>Selbstverständlich sind dies theoretische Werte, die oft durch die
    verfügbaren Platten- und Speicherressourcen beschränkt werden.
    Extreme Größen können zu Leistungseinbußen führen.</p>

    <p>Die maximale Tabellengröße von 32 TB benötigt keine Large-File-Unterstützung
    im Betriebssystem. Große Tabellen werden in Dateien mit einer Größe von
    je 1 GB aufgeteilt, wodurch etwaige dateisystem-bedingte Beschränkungen nicht
    relevant sind.</p>

    <p>Die maximale Tabellengröße und die maximale Anzahl von Spalten können
    vervierfacht werden, indem man die Default-Blockgröße auf 32 KB heraufsetzt.</p>

    <h4><a name="4.6">4.6</a>) Wieviel Plattenplatz wird benötigt, um die Daten aus einer typischen
    Textdatei abzuspeichern? </h4>
 
    <p>Eine PostgreSQL-Datenbank kann beim Abspeichern einer einfachen Textdatei
    bis zu fünfmal mehr Platz gegenüber der eigentlichen Größe der Datei
    beanspruchen.</p>

    <p>Betrachten wir eine Datei mit 100.000 Zeilen mit einem Integer und einer
    Textbeschreibung pro Zeile. Gehen wir davon aus, dass die durchschnittliche
    Länge der Textbeschreibung 20 Byte beträgt. Die einfache Datei würde 2,8 MB
    groß sein. Die Größe der PostgreSQL-Datenbankdatei, die diese Daten enthält,
    liegt ungefähr bei 6,4 MB:</p>
<pre>
    32 Bytes: jeder Zeilenkopf (ungefähr)
   +24 Bytes: ein Integer-Feld und ein Textfeld
   + 4 Bytes: Zeiger auf der Datenseite auf den Tupel
   -----------------------------------------------
    60 Bytes pro Zeile
</pre>
    <p>Die Größe einer Datenseite in PostgreSQL beträgt 8192 Bytes (8 KB), also:</p>
<pre>
   8192 Bytes pro Seite
   ---------------------   =  136 Zeilen pro Seite (abgerundet)
     64 Bytes pro Zeile

   100.000 Datenzeilen
   ------------------------  =  735 Datenbankseiten (aufgerundet)
       128 Zeilen pro Seite

   735 Datenbankseiten * 8192 Bytes pro Seite  =  6.021.120 Byte (6 MB)
</pre>
    <p>Indizes beanspruchen nicht so viel Platz. Da sie jedoch die
    Daten beinhalten, die sie indizieren, können auch sie sehr groß werden.</p>

    <p>NULL-Werte werden als Bitmaps gespeichert, wodurch sie sehr wenig
    Platz in Anspruch nehmen.</p>

    <h4><a name="4.7">4.7</a>) Meine Abfragen sind langsam oder benutzen die Indizes nicht. Warum?</h4>

    <p>Indizes werden nicht automatisch bei jeder Abfrage verwendet. Indizes werden
    nur dann verwendet, wenn die abzufragende Tabelle eine bestimmte Größe
    übersteigt,  und die Abfrage nur eine kleine Prozentzahl der Tabellenzeilen
    abfragt. Der Grund hierfür ist der, dass die durch einen Index verursachten
    Festplattenzugriffe manchmal länger dauern würden als ein einfaches Auslesen
    aller Tabellenzeilen (sequentieller Scan).</p>

    <p>Um festzustellen, ob ein Index verwendet werden soll, braucht PostgreSQL
    Statistiken über die Tabelle. Diese Statistiken werden durch die Anweisungen
    <small>VACUUM ANALYZE</small> bzw. <small>ANALYZE</small> berechnet. Anhand der Statistiken kennt der
    Abfragenoptimierer die Anzahl der Tabellenzeilen und kann besser
    entscheiden, ob Indizes verwendet werden sollen. Statistiken sind auch
    bei der Ermittlung der optimalen <small>JOIN</small>-Reihenfolgen und
    -Methoden wertvoll. Daher sollten diese regelmässig durchgeführt werden, da
    sich der Inhalt einer Tabelle ja auch verändert</p>

    <p>In Versionen vor 8.0 werden Indizes oft nicht benutzt, wenn die
    jeweiligen Datentypen nicht genau übereinstimmen. Dies gilt besonders für 
    Spalten mit numerischen und Integer-Werten.</p>

    <p>Indizes werden normalerweise nicht in <small>ORDER BY</small>-Abfrage oder in JOINs
    verwendet. Ein sequentieller Scan mit anschließendem explizitem
    Sortiervorgang ist normalerweise schneller als ein Index-Scan einer
    großen Tabelle. Jedoch wird bei einer Abfrage, in der <small>LIMIT</small> zusammen mit
    <small>ORDER BY</small> verwendet wird, oftmals ein Index verwendet, da nur ein
    kleiner Abschnitt der Tabelle zurückgeliefert wird. Dadurch wird es
    auch möglich, die Minimal- und Maximalwerte einer Abfrage unter
    Verwendung von Indizes zu ermitteln:</p>
<pre>
       SELECT spalte
         FROM tabelle
     ORDER BY spalte [ DESC ]
        LIMIT 1
</pre>
    <p>(Die Aggregatfunktionen MIN() und MAX() verwenden keine Indizes). </p>

    <p>Sollte es danach aussehen, also ob der Optimierer irrtümlich einen sequentiellen 
    Scan ausführt, führen Sie <small>SET enable_seqscan TO 'off'</small> aus und prüfen
    Sie, ob die Indexabfrage dadurch scheller geworden ist.</p>

    <p>Bei der Nutzung von Wildcard-Operatoren wie <small>LIKE</small> oder <small>~</small>, können
    Indizes nur unter bestimmten Umständen verwendet werden:</p>
  <ul>
    <li>Das Suchmuster muss sich an Anfang des Strings befinden, d.h.:
      <ul>
        <li><small>LIKE</small>-Suchmuster dürfen nicht mit <em>%</em> anfangen;</li>
        <li><small>~</small> (reguläre Ausdrücke) müssen mit <em>^</em> anfangen.</li>
      </ul>
    </li>
    <li>Das Suchmuster darf nicht mit einer Zeichenklasse (z.B. <em>[a-e]</em>)
    beginnen.</li>
  </ul>
    <p>Suchmuster, die Gross- und Kleinschreibung nicht berücksichtigen (z.B.
    <small>ILIKE</small> bzw. <small>~*</small>), verwenden keine Indizes. Stattdessen können
    funktionale Indizes verwendet werden, die im Punkt <a href="#4.12">4.12</a> beschrieben werden.</p>

    <p>Die Standard-Locale "C" muss während der Datenbank-Initialisierung mit <em>initdb</em>
    verwendet worden sein, da andere <em>locales</em> den nächstgrößten Wert nicht
    ermitteln können. Es ist allerdings möglich, einen besonderen <small>text_pattern_ops</small>-Index 
    für solche Fälle zu erstellen.</p>

    <h4><a name="4.8">4.8</a>) Auf welche Weise kann ich sehen, wie der Abfrage-Optimierer meine
    Abfrage auswertet?</h4>

    <p>Vgl. die <em>EXPLAIN</em> Man-Page.</p>

    <h4><a name="4.9">4.9</a>) Was ist ein R-Tree Index?</h4>

    <p>Ein R-Tree Index wird benutzt, um räumliche Daten zu indizieren. Ein
    Hash-Index kann nicht für Bereichssuchen genutzt werden. Ein B-Tree
    Index kann nur für Bereichssuchen in eindimensionalen Daten genutzt
    werden. R-Trees können hingegen auch mit multi-dimensionalen Daten umgehen. Ein
    Beispiel: Wenn ein R-Tree Index auf ein Attribut vom Typ <small>POINT</small>
    gebildet wird, dann kann das System Abfragen wie z.B. "Zeige alle
    Punkte, die sich in einem umgebenden Rechteck befinden" effizienter
    beantworten.</p>

    <p>Die kanonische Veröffentlichung, die das originale R-Tree Design
    beschreibt, ist:</p>

    <p>Guttman, A. "R-Trees: A Dynamic Index Structure for Spatial Searching."
    Proc of the 1984 ACM SIGMOD Int'l Conf on Mgmt of Data, 45-57.</p>

    <p>Sie können dieses Werk auch in Stonebrakers "Readings in Database
    Systems" finden.</p>

    <p>Die eingebauten R-Trees können Polygone und Rechtecke verarbeiten.
    Theoretisch können R-Trees auf eine hohe Anzahl von Dimensionen
    erweitert werden. Für die Praxis bedeutet eine solche Erweiterung allerdings eine Menge
    Arbeit und wir haben derzeit keinerlei Dokumentation darüber, wie das
    zu machen wäre.</p>

    <h4><a name="4.10">4.10</a>) Was ist der "<em>Genetic Query Optimizer</em>"?</h4>

    <p>Das <small>GEQO</small>-Modul in PostgreSQL soll dazu dienen, das Optimierungsproblem
    beim <small>JOIN</small> von vielen Tabellen auf der Basis genetischer Algorithmen
    (GA) zu lösen. Es ermöglicht die Behandlung von großen JOIN-Queries durch
    eine nicht-erschöpfende Suche.</p>

    <h4><a name="4.11">4.11</a>) Wie verfahre ich bei der Suche mit regulären Ausdrücken und bei einer
    Suche, bei der Groß- und Kleinschreibweisen ignoriert werden? Wie verwende
    ich einen Index bei solchen Suchabfragen?</h4>

    <p>Der Operator <em>~</em> wendet einen regulären Ausdruck an und <em>~*</em> wendet ihn an, ohne die Groß- und Kleinschreibung zu beachten.
     Ebenso beachtet <small>LIKE</small> die Groß- und Kleinschreibung, und <small>ILIKE</small> nicht.</p> 

    <p>Gleichheitsvergleiche, die Groß- und Kleinschreibung ignorieren, werden
    in der Regel so ausgedruckt:</p>
<pre>
      SELECT *
        FROM tabelle
       WHERE LOWER(spalte) = 'abc'
</pre>
    <p>Hier kann kein normaler Index benutzt werden. Legt man hingegen
    einen funktionalen Index an, so wird er auf jeden Fall verwendet:</p>
<pre>
      CREATE INDEX tabelle_index ON tabelle (LOWER(spalte))
</pre>
    <h4><a name="4.12">4.12</a>) Wie ermittle ich in einer Abfrage, ob ein Feld NULL ist?</h4>

    <p>Testen Sie die Spalte mit <small>IS NULL</small> bzw. <small>IS NOT NULL</small>.</p>

    <h4><a name="4.13">4.13</a>) Was ist der Unterschied zwischen den verschiedenen <small>CHAR</small>-Typen?</h4><pre>
Typ           interner Name   Bemerkungen
-------------------------------------------------
VARCHAR(n)    varchar         die Größe legt die Maximallänge fest; kein
                              Auffüllen mit Leerzeichen
CHAR(n)       bpchar          mit Leerzeichen gefüllt bis zur angegebenen Länge
TEXT          text            keine obere Schranke für die Länge
BYTEA         bytea           Bytearray mit variabler Länge (auch für
                              '\0'-Bytes geeignet)
"char"        char            1 Zeichen
</pre>
    <p>Der <em>interne Name</em> kommt vor allem in den Systemkatalogen und in manchen
    Fehlermeldungen vor.</p>

    <p>Die ersten vier Typen sind "<em>varlena</em>"-Typen (d.h. die ersten vier
    Bytes geben die Länge an, gefolgt von den Daten). Daher ist der tatsächlich
    belegte Platz immer etwas mehr als die deklarierte Feldgröße. Allerdings
    wird unter Umständen auf diese Datentypen Datenkompression durch das <small>TOAST</small>-
    Verfahren angewendet, womit der tatsächlich belegte Platz auch geringer
    als erwartet ausfallen kann.</p>

    <p>Für die Speicherung von Zeichenketten variabler Länge empfiehlt sich <small>VARCHAR(n)</small>. 
    Die maximale Länge eines <small>VARCHAR(n)</small>-Felds wird bei der Tabellendefinition
    festgelegt. <small>TEXT</small> setzt keine Längengrenze, allerdings gibt es
    eine systembedingte Obergrenze von 1 GB. </p>

    <p><small>CHAR(n)</small> ist geeignet für die Speicherung von Zeichenketten, die alle 
    die gleiche Länge haben. Bitte beachten Sie, dass <small>CHAR(n)</small> automatisch Zeichenketten
    bis zur definierten Feldlänge mit Leerzeichen ausfüllt, während bei <small>VARCHAR(n)</small> nur
    die tatsächlich eingegebene Zeichenkette gespeichert wird.</p>

    <p><small>BYTEA</small> ist für binäre Daten, besonders für Werte, die <small>NULL</small>-Bytes haben. </p>
    <p>Alle der hier erwähnten Typen weisen ähnliche Performanzeigenschaften auf.</p>

    <h4><a name="4.14.1">4.14.1</a>) Wie erzeuge ich ein serielles Feld mit automatischer Erhöhung des
    Werts (serial/auto-increment)?</h4>

    <p>PostgreSQL bietet einen <small>SERIAL</small>-Datentyp. Dieser erzeugt automatisch
    eine Sequenz auf die angegebene Spalte. Zum Beispiel:</p>
<pre>
      CREATE TABLE person (
          id   SERIAL,
          name TEXT
      )</pre>
    <p>wird automatisch in:</p>
<pre>
      CREATE SEQUENCE person_id_seq;
      CREATE TABLE person (
        id   INT4 NOT NULL DEFAULT nextval('person_id_seq'),
        name TEXT
      );
</pre><p>umgewandelt.</p>

    <p>Die <em>create_sequence</em> Man-Page liefert weitere Informationen über Sequenzen.
    Es ist auch möglich, den <small>OID</small>-Wert jeder Spalte als einmaligen Wert
    einzusetzen. Sollten Sie allerdings die Datenbank exportieren und
    reimportieren wollen, müssen Sie die Option <em>-o</em> von <em>pg_dump</em> bzw. <small>COPY
    WITH OIDS</small> verwenden, um die <small>OID</small>s beizubehalten.</p>

    <h4><a name="4.14.2">4.14.2</a>) Wie bekomme ich den Wert einer <small>SERIAL</small>-Sequenz?</h4>

    <p>Eine Möglichkeit wäre, mit der <em>nextval()</em>-Funktion den nächsten <small>SERIAL</small>-Wert
    von dem Sequenzobjekt vor der Auszuführung einer <small>INSERT</small>-Anweisung anzufordern und ihn 
    dann explizit in die <small>INSERT</small>-Anweisung einzubinden. Anhand der Beispieltabelle in
    <a href="#4.14.1">4.14.1</a> könnte dieser Vorgang in einer Pseudosprache so aussehen:</p>
<pre>
    new_id = output of execute("SELECT nextval('person_id_seq')");
    execute("INSERT INTO person (id, name) VALUES (new_id, 'Blaise Pascal')");
</pre>
    <p>Danach stünde der neue Wert in der Variablen <em>new_id</em> für die Verwendung in
    weiteren Abfragen zur Verfügung, zum Beispiel als Fremdschlüssel zur
    Tabelle 'person'). Bitte beachten Sie, dass der Name des automatisch
    erstellten <small>SEQUENCE</small>-Objektes folgenden Name hat:
    <em>&lt;table&gt;_&lt;serialcolumn&gt;_seq</em>
    wobei '<em>table</em>' und '<em>serialcolumn</em>' die Namen der jeweils betreffenden
    Tabelle / Spalte darstellen.</p>

    <p>Als weitere Möglichkeit können Sie nach einer <small>INSERT</small>-Anweisung den
    automatisch eingefügten <small>SERIAL</small>-Wert mit der <em>currval()</em>-Funktion zurückgeben
    lassen:</p>
<pre>
    execute("INSERT INTO person (id, name) VALUES (new_id, 'Blaise Pascal')");
    new_id = output of execute("SELECT currval('person_id_seq')");
</pre>
    <p>Schließlich besteht noch die Möglichkeit, den von einer <small>INSERT</small>-Anweisung
    zurückgelieferten <a href="#4.15"><small>OID</small></a>-Wert als einmaligen Wert zu verwenden.
    Dieser Ansatz ist allerdings PostgreSQL-spezifisch; außerdem wird nach 
    ca. 4 Milliarden Einträgen der <small>OID</small>-Wert wieder auf eine kleine Zahl
    gesetzt, ist also nicht garantiert immer einmalig oder aufsteigend.</p>

    <p>Mit zum Beispiel dem <em>DBD::Pg</em>-Modul von Perl wird der OID-Wert nach einem
    <em>$sth->excute()</em> über <em>$sth->{pg_oid_status}</em> zurückgeliefert.</p>

    <h4><a name="4.14.3">4.14.3</a>) Führen <em>currval()</em> und <em>nextval()</em> zu einer Race-Condition mit anderen
     Nutzern?</h4>

    <p>Nein. <em>currval()</em> liefert einen Wert zurück, der von Ihrem Backend
    bestimmt wird, und der anderen Benutzern nicht zur Verfügung steht.</p>

    <h4><a name="4.14.4">4.14.4</a>) Warum werden die Sequenzwerte nach einem Transaktionsabbruch nicht
     zurückgesetzt? Warum gibt es Lücken in der Nummerierung meiner
     Sequenz-/<small>SERIAL</small>-Spalte?</h4>

    <p>Um die gleichzeitige Abarbeitung von Transaktionen zu verbessern, werden
    Sequenzen gerade nicht für andere Transaktionen gesperrt, sondern die
    Sequenznummern werden den laufenden Transaktionen sofort zugeteilt. Lücken in 
    der Sequenznummerierung werden durch abgebrochene Transaktionen verursacht.</p>

    <h4><a name="4.15">4.15</a>) Was ist ein <small>OID</small>? Was ist ein <small>TID</small>?</h4>

    <p><small>OID</small>s sind PostgreSQLs Antwort auf eindeutige Zeilen-IDs. Jede Zeile,
    die in PostgreSQL erzeugt wird, bekommt eine eindeutige <small>OID</small>. Alle
    <small>OID</small>s, die durch initdb erzeugt werden, sind kleiner als 16384 (siehe
    include/access/transam.h). Alle <small>OID</small>s, die durch den Benutzer erzeugt
    werden, sind größer oder gleich diesem Wert. Standardmäßig sind
    all <small>OID</small>s nicht nur innerhalb einer Tabelle oder Datenbank,
    sondern in der gesamten PostgreSQL-Installation einmalig.</p>
   
    <p>PostgreSQL benutzt <small>OID</small>s in seinen internen Systemtabellen, um Zeilen
    in JOINs zwischen Tabellen zu verknüpfen. Es ist möglich, einen Index
    für die <small>OID</small>-Spalte zu erstellen, wodurch schnellere Zugriffszeiten
    erreicht werden können. Es wird empfohlen, <small>OID</small>-Werte in Spalten vom Typ <small>OID</small>
    zu speichern.</p>

    <p><small>OID</small>s werden allen neuen Zeilen von einem zentralen Bereich, der von
    allen Datenbanken genutzt wird, zugewiesen. Nichts hindert Sie daran,
    die <small>OID</small> zu ändern, oder eine Kopie der Tabelle mit den originalen <small>OID</small>s
    anzulegen:</p>
<pre>
        CREATE TABLE new_table(mycol int);
        SELECT oid AS old_oid, mycol INTO tmp_table FROM old_table;
        COPY tmp_table TO '/tmp/pgtable';
        COPY new_table WITH OIDS FROM '/tmp/pgtable';
        DROP TABLE tmp_table;
</pre>

    <p>O<small>ID</small>s werden als 4-Byte Integer gespeichert und laufen bei
    einem Wert von ungefähr 4 Milliarden über. Niemand hat jemals davon
    berichtet, dass dies passiert wäre aber wir haben geplant, diese
    Beschränkung aufzuheben, bevor das jemand ausprobieren kann.</p>

    <p>T<small>ID</small>s werden benutzt, um bestimmte physikalische Zeilen
    durch Block und Offset Werte zu identifizieren. T<small>ID</small>s
    verändern sich, sobald Zeilen verändert oder zurückgeladen werden. Sie
    werden in Indexeinträgen benutzt um auf die physikalischen Zeilen zu
    zeigen.</p>

    <h4><a name="4.16">4.16</a>) Welche Bedeutung haben die verschiedenen Ausdrücke, die in
    PostgreSQL benutzt werden (z.B. attribute, class,...)?</h4>

    <p>Einige der Quelltexte und die ältere Dokumentation nutzen allgemeine
    Begriffe. Hier sind einige aufgeführt:</p>
    <ul>
      <li>row, record, tuple</li>
      <li>attribute, field, column</li>
      <li>table, class</li>
      <li>retrieve, SELECT</li>
      <li>replace, UPDATE</li>
      <li>append, INSERT</li>
      <li><small>OID</small>, serial value</li>
      <li>portal, cursor</li>
      <li>range variable, table name, table alias</li>
    </ul>

    <p>Eine allgemeine Liste der Datenbank-Terminologie erhalten Sie hier:
    <a href="http://hea-www.harvard.edu/MST/simul/software/docs/pkgs/pgsql/glossary/glossary.html">http://hea-www.harvard.edu/MST/simul/software/docs/pkgs/pgsql/glossary/glossary.html</a>
    (engl.).</p>

    <h4><a name="4.17">4.17</a>) Wieso bekomme ich einen Fehler: "<em>ERROR: Memory exhausted in
    AllocSetAlloc()</em>"?</h4>

    <p>Wahrscheinlich gibt es keinen virtuellen Speicher mehr in Ihrem System
    oder Ihr Kernel hat niedrige Höchstgrenzen für bestimmte Ressourcen.
    Probieren Sie vor dem Start von <em>postmaster</em> folgendes:</p>
<pre>
      ulimit -d 262144
      limit datasize 256m
</pre>
    <p>Je nach benutzter Shell wird nur einer dieser Befehle erfolgreich
    ausgeführt werden. Auf jedem Fall wird die Grenze des Datensegments für
    Prozesse erhöht werden und eventuell die erfolgreiche Ausführung der
    Abfrage ermöglichen. Falls Sie ein Problem mit dem SQL-CLient haben,
    weil das Backend zu viele Daten zurückliefert, versuchen Sie dies vor dem
    Start des SQL-Clients.</p>

    <h4><a name="4.18">4.18</a>) Wie kann ich feststellen, welche PostgreSQL-Version bei mir läuft?</h4>

    Geben Sie in <em>psql</em> <small>SELECT VERSION();</small> ein.

    <h4><a name="4.19">4.19</a>) Bei "large-object"-Operationen kommt die Fehlermeldung: "<em>invalid
    large obj descriptor</em>". Warum?</h4>

    <p>Sie sollten die Anweisungen <small>BEGIN WORK</small> und <small>COMMIT</small> bei jeden Gebrauch von
    Large Objects benutzen. Also um <small>lo_open</small> ... <small>lo_close</small>.</p>

    <p>Derzeit erzwingt PostgreSQL diese Regel, indem es die Handles der
    Large Objects beim <small>COMMIT</small> der Transaktion schließt. So führt der erste
    Versuch, etwas mit dem <em>Large Object</em> zu machen, zu einer Meldung
    "<em>invalid large obj descriptor</em>". Solange Sie keine Transaktionen benutzen,
    wird der Code, der in älteren PostgreSQL-Versionen funktionierte,
    nun diese Fehlermeldung erzeugen.</p>

    <p>Falls Sie eine Client-Schnittstelle wie ODBC benutzen, kann es sein,
    dass die <em>auto-commit</em>-Option ausgeschaltet werden muss.</p>

    <h4><a name="4.20">4.20</a>) Wie kann ich eine Spalte erstellen, deren Default-Wert immer
    die aktuelle Uhrzeit enthalten soll?</h4>

    <p>Dazu verwenden Sie <small>CURRENT_TIMESTAMP</small>:</p>
<pre>
      CREATE TABLE test (x int, modtime timestamp DEFAULT CURRENT_TIMESTAMP );
</pre>
    <h4><a name="4.21">4.21</a>) Warum sind meine Unterabfragen (subqueries), die IN verwenden,
    so langsam?</h4>

    <p>In Versionen vor 7.4 werden Unterabfragen mit der äusseren Abfrage verbunden, 
    in dem für jede Reihe der äusseren Query die Ergebnisse der Unterabfrage
    sequentiell geprüft werden. Um dies zu vermeiden, kann man <small>IN</small> durch
    <small>EXISTS</small> ersetzen, z.B.:</p>
<pre>
      SELECT *
        FROM tabelle_1
       WHERE spalte1 IN (SELECT spalte2 FROM tabelle_2)
</pre>
    <p>ersetzen durch:</p>
<pre>
      SELECT *
        FROM tabelle_1
       WHERE EXISTS (SELECT spalte2 FROM tabelle_2 WHERE spalte1 = spalte2)
</pre>
    <p> Damit diese Abfrage effizient durchgeführt wird, sollte für '<em>spalte2</em>'
    ein Index angelegt worden sein. Ab PostgreSQL 7.4 verwendet <small>IN</small>
    die gleichen Methoden wie die normale Tabellenverknüpfung und ist daher soger
    <small>EXISTS</small> vorzuziehen.
    </p>

    <h4><a name="4.22">4.22</a>) Wie führe ich einen <small>OUTER JOIN</small> durch?</h4>

    <p>PostgreSQL ab der Version 7.1 unterstützt <small>OUTER JOIN</small>s nach dem SQL-
    Standardsyntax. Hier zwei Beispiele:</p>
<pre>
      SELECT *
        FROM tabelle_1 t1
             LEFT OUTER JOIN tabelle_2 t2 ON (t1.spalte = t2.spalte)
</pre>
    <p>bzw.:</p>
<pre>
      SELECT *
        FROM tabelle_1 t1
             LEFT OUTER JOIN tabelle_2 t2 USING (spalte)
</pre>
    <p>
    Diese identischen Abfragen verknüpfen <em>tabelle_1</em> mit <em>tabelle_2</em> über die
    Spalte '<em>spalte</em>' und geben außerdem alle unverknüpften Zeilen in tabelle_1
    (diejenigen, die keine Entsprechung in <em>tabelle_2</em> haben) zurück.
    Ein <small>RIGHT JOIN</small> würde hingegen alle unverknüpften Zeilen in tabelle_2 hinzufügen und
    ein <small>FULL JOIN</small> würde alle verknüpften Zeilen sowie jeweils alle
    unverknüpften Zeilen aus den beiden Tabellen zurückliefern. Die Angabe von
    OUTER ist nicht zwingend und kann in <small>LEFT</small>, <small>RIGHT</small> und <small>FULL</small>-Verknüpfungen
    weggelassen werden. Normale Verknüpfungen sind <small>INNER JOIN</small>s.</p>

    <p>In früheren Versionen von PostgreSQL konnten <small>OUTER JOIN</small>s mittels <small>UNION</small>
    und <small>NOT IN</small> simuliert werden. Zum Beispiel '<em>tabelle_1</em>' und '<em>tabelle_2</em>'
    können als <small>LEFT OUTER JOIN</small> auch so verknüpft werden:</p>
<pre>
      SELECT t1.spalte1, t2.spalte2
        FROM tabelle_1 t1, tabelle_2 t2
       WHERE t1.spalte1 = t2.spalte1
       UNION ALL
      SELECT t1.spalte1, NULL
        FROM tabelle_1 t1
       WHERE t1.spalte1 NOT IN (SELECT t2.spalte1 FROM tabelle_2 t2)
       ORDER BY spalte1
</pre>

    <h4><a name="4.23">4.23</a>) Wie kann ich Abfragen über mehrere Datenbanken hinweg ausführen?</h4>

    <p>Es gibt keinen Weg, innerhalb einer Abfrage auf mehr als eine Datenbank
    zuzugreifen. Da PostgreSQL datenbank-spezifische Systemkataloge lädt, ist
    eine datenbankübergreifende Abfrage nicht möglich.</p>

    <p><em>contrib/dblink</em> ist eine Erweiterung, die datenbankübergreifende Abfragen über
    Funktionsaufrufe ermöglicht.</p>

    <p>Es ist natürlich möglich, dass eine Client-Anwendung gleichzeitige Verbindungen
    zu verschiedenen Datenbanken aufbaut und selber Datensätze zusammenfügt.</p>

    <p>Ab 7.3 unterstützt PostgreSQL <em>schemas</em>, die die Aufteilung einer Datenbank
    in mehrere logische Bereiche ermöglichen. Bei vielen Anwendungen könnten diese
    einen geeigneten Ersatz für den Zugriff auf eine andere Datenbank bieten.</p>

    <h4><a name="4.24">4.24</a>) Wie kann ich mehrere Zeilen bzw. Spalten von einer Funktion
    zurückgeben lassen?</h4>

    <p>Ab 7.3 können Funktionen mehrere Zeilen und Spalten zurückgeben, vgl.:
     <a href="http://techdocs.postgresql.org/guides/SetReturningFunctions">http://techdocs.postgresql.org/guides/SetReturningFunctions</a>.</p>

    <h4><a name="4.25">4.25</a>) Warum kann ich temporäre Tabellen in <small>PL/PgSQL</small>-Funktionen nicht
    zuverlässig erstellen bzw. löschen?</h4>

    <p><small>PL/PgSQL</small> verarbeitet die Inhalte einer Funktion in eine Cache. Dies hat
    eine unangenehme Nebenwirkung, nämlich dass wenn eine <small>PL/PgSQL</small>-
    Funktion auf eine temporäre Tabelle zugreift, und diese Tabelle
    anschließend gelöscht bzw. neu erstellt wird, die Funktion
    fehlschlagen wird, da die gecachten Funktionsinhalte noch auf die alte
    temporäre Tabelle zeigen.</p>

    <p>Die Lösung für diese Probleme besteht darin, in der <small>PL/PgSQL</small> Funktion mittels
    <small>EXECUTE</small> auf temporäre Tabellen zuzugreifen. Diese bewirkt, dass bei
    jedem Funktionsruf die betreffende Abfrage neu geparst wird.</p>

    <h4><a name="4.26">4.26</a>) Welche Möglichkeiten zur Verschlüsselung gibt es?</h4>

    <ul>
    <li><em>contrib/pgcrypto</em> enthält diverse Funktionen für die Benützung mit
      SQL-Abfragen.</li>

    <li>Um Verbindungen zwischen dem Server und Client-Anwendungen zu
      verschlüsseln, muss in der Server-Konfigurationsdatei <em>postgresql.conf</em>
      die <em>ssl</em>-Option auf <em>true</em> (Voreinstellung: <em>false</em>) gesetzt werden
      und ein passender <em>host</em>- bzw. <em>hostssl</em>-Eintrag muss in 
      <em>pg_hba.conf</em> vorhanden sein. Zudem muss die <em>sslmode</em>-Einstellung
      beim Client nicht auf <em>disable</em> gesetzt werden. (Bitte beachten Sie auch,
      daß neben der eingebauten SSL-Unterstützung verschlüsselte Verbindungen 
      auch über externe Anwendungen wie <em>stunnel</em> oder <em>ssh</em> aufgebaut werden können).</li>

    <li>Die Passwörter der Datenbanknutzer werden ab Version 7.3 automatisch
      verschlüsselt (in früheren Versionen muß der Parameter <em>PASSWORD_ENCRYPTION</em>
      in <em>postgresql.conf</em> explizit eingeschaltet werden).</li>
    <li>Betrieb des Servers auf einem verschlüsselten Dateisystem.</li>
    </ul>

    <hr />

    <h2 align="center">PostgreSQL erweitern</h2>

    <h4><a name="5.1">5.1</a>) Ich habe eine benutzerdefinierte Funktion geschrieben.  Wenn ich sie in
    <em>psql</em> aufrufe, kommt ein <em>core dump</em>. Warum?</h4>

    <p>Dieses Problem kann viele Ursachen haben. Testen Sie Ihre Funktion zuerst
    in einem eigenen Testprogramm.</p>

    <h4><a name="5.2">5.2</a>) Wie kann ich praktische neue Typen und Funktionen zu PostgreSQL
    hinzufügen?</h4>

    <p>Senden Sie Ihre Beiträge an die Mailing Liste <em>pgsql-hackers</em>, und sie
    werden nach Prüfung eventuell ins <em>contrib/</em> Verzeichnis des Quellcodes
    aufgenommen werden.</p>

    <h4><a name="5.3">5.3</a>) Wie schreibe ich eine Funktion in C, die einen Tupel zurückliefert?</h4>

    <p>Ab PostgreSQL 7.3 werden Funktionen, die Tupel zurückliefern, in C, PL/PgSQL und SQL
    unterstützt. Der <i>Programmer's Guide</i> enthält weitere Informationen
    dazu. Ein Bespiel einer solchen Funktion befindet sich in <em>contrib/tablefunc</em>.</p>

    <h4><a name="5.4">5.4</a>) Ich habe eine der Quellendateien geändert. Warum macht sich
    die Änderung beim erneuten Kompilieren nicht bemerkbar?</h4>

    <p>Die <em>Makefiles</em> enthalten nicht die richtigen Abhängigkeiten für <em>include</em>-
    Dateien. Sie müssen ein "<em>make clean</em>" und dann ein weiteres "<em>make</em>" ausführen.
    Wenn Sie <em>gcc</em> benutzen, können Sie die "<em>--enable-depend</em>"-Option des <em>configure</em>-
    Skripts benutzen, damit der Compiler die Abhängigkeiten automatisch
    ermittelt.</p>

    <hr />

    <h4>Anmerkungen des Übersetzers</h4>

    <p>Die englische Vorlage dieser FAQ wird ständig überarbeitet. Daher liegt
    die Übersetzung nicht immer auf dem aktuellsten Stand.</p>

    <p>Die aktuellste Version der deutschen Übersetzung befindet sich immer unter
    <a href="http://sql-info.de/de/postgresql/FAQ_german.html">http://sql-info.de/de/postgresql/FAQ_german.html</a>.
    Diese "Arbeitsversion" enthält eventuell Änderungen, die noch nicht auf der 
    PostgreSQL-Website eingebunden worden sind.</p>

    <p>Über Verbesserungshinweise und Korrekturvorschläge sowie Verständnisfragen
    zum Inhalt der FAQ freue ich mich. Ich nehme auch allgemeine Fragen zu PostgreSQL gerne
    entgegen, verweise jedoch auf die Mailing-Listen als schnelle und zuverlässige
    Anlaufstellen.</p>

</body>
</html>


