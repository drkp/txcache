
                  Häufig gestellte Fragen (FAQ) zu PostgreSQL
                                       
   Current maintainer: Bruce Momjian (pgman@candle.pha.pa.us).
   
   Deutsche Übersetzung von Ian Barwick (barwick@gmx.net).
   
   Letzte Aktualisierung der deutschen Übersetzung: So., den 16.1.2005,
   22:30 MEZ
   
   Die aktuellste Version dieses Dokuments liegt auf der
   PostgreSQL-Website:
     * http://www.postgresql.org/files/documentation/faqs/FAQ.html
       (engl.)
     * http://www.postgresql.org/files/documentation/faqs/FAQ_german.html
       (dt.)
       
   Übersetzungen dieses Dokuments in andere Sprachen sowie plattform-
   spezifische FAQs können unter http://www.postgresql.org/docs/faq/
   eingesehen werden.
     _________________________________________________________________
   
                             Allgemeine Fragen
                                      
   1.1) Was ist PostgreSQL? Wie wird es ausgesprochen?
   1.2) Welchem Copyright unterliegt PostgreSQL?
   1.3) Auf welchen Unix-Plattformen läuft PostgreSQL?
   1.4) Welche Nicht-Unix-Versionen sind verfügbar?
   1.5) Woher bekomme ich PostgreSQL?
   1.6) Wo bekomme ich Support für PostgreSQL?
   1.7) Was ist die neueste Version von PostgreSQL?
   1.8) Welche Dokumentation ist für PostgreSQL verfügbar?
   1.9) Wie erfahre ich von bekannten Bugs oder fehlenden Features?
   1.10) Wie kann ich SQL lernen?
   1.11) Ist PostgreSQL Y2K (Jahr 2000) fähig?
   1.12) Wie kann ich im Entwicklerteam mitarbeiten?
   1.13) Wie sende ich einen Fehler-Bericht?
   1.14) Wie läuft PostgreSQL im Vergleich zu anderen Datenbanksystemen?
   1.15) Wie kann ich PostgreSQL finanziell unterstützen?
   
                        Fragen zu Benutzerprogrammen
                                      
   2.1) Gibt es ODBC-Treiber für PostgreSQL?
   2.2) Welche Werkzeuge gibt es, um Web-Seiten mit PostgreSQL zu
   verbinden?
   2.3) Hat PostgreSQL eine grafische Benutzerschnittstelle?
   2.4) Welche Programmiersprachen können mit PostgreSQL kommunizieren?
   
                           Administrative Fragen
                                      
   3.1) Wie installiere ich PostgreSQL woanders als in /usr/local/pgsql?
   3.2) Wenn ich den postmaster starte, erhalte ich die Nachricht "Bad
   System Call" bzw. "core dumped". Warum?
   3.3) Wenn ich versuche, den postmaster zu starten, bekomme ich
   "IpcMemoryCreate"-Fehlermeldungen. Warum?
   3.4) Wenn ich versuche, den postmaster zu starten, bekomme ich
   "IpcSemaphoreCreate"-Fehlermeldungen. Warum?
   3.5) Wie regle ich Zugriffe von anderen Rechnern?
   3.6) Wie optimiere ich die Datenbank für bessere Leistung?
   3.7) Welche Debugging-Funktionen sind bei PostgreSQL verfügbar?
   3.8) Ich bekomme die Meldung "Sorry, too many clients", wenn ich eine
   Verbindung aufzubauen versuche. Warum?
   3.9) Was befindet sich im Verzeichnis pgsql_tmp/?
   3.10) Warum muß ich bei jeder neuen Hauptversion von PostgreSQL die
   komplette Datenbank exportieren und anschließend reimportieren?
   3.11) Welche Hardware eignet sich für den Betrieb mit PostgreSQL?
   
                             Fragen zum Betrieb
                                      
   4.1) Worin besteht der Unterschied zwischen Binary Cursors und Normal
   Cursors?
   4.2) Wie wähle ich per SELECT-Anweisung nur die ersten paar Zeilen
   bzw. eine beliebige Zeile in einer Abfrage aus?
   4.3) Wie finde ich heraus, welche Tabellen, Indizes, Datenbanken oder
   Benutzer in der Datenbank definiert sind? Wie bekomme ich die von psql
   verwendeten Abfragen?
   4.4) Wie entferne ich eine Spalte aus einer Tabelle? Wie ändere ich
   den Datentyp einer Spalte?
   4.5) Was ist die Maximalgröße für eine Zeile, eine Tabelle, eine
   Datenbank?
   4.6) Wieviel Plattenplatz wird benötigt, um die Daten aus einer
   typischen Textdatei abzuspeichern?
   4.7) Meine Abfragen sind langsam oder nutzen die Indizes nicht. Warum?
   4.8) Auf welche Weise kann ich sehen, wie der Abfrage-Optimierer
   ("GEQO") meine Abfrage auswertet?
   4.9) Was ist ein R-Tree Index?
   4.10) Was ist der "Genetic Query Optimizer"?
   4.11) Wie verfahre ich bei der Suche mit regulären Ausdrücken und bei
   einer Suche, bei der Groß- und Kleinschreibweisen ignoriert werden?
   Wie verwende ich bei solchen Suchabfragen einen Index?
   4.12) Wie ermittle ich in einer Abfrage, ob ein Feld NULL ist?
   4.13) Was ist der Unterschied zwischen den verschiedenen CHAR-Typen?
   4.14.1) Wie erzeuge ich ein serielles Feld mit automatischer Erhöhung
   des Wertes?
   4.14.2) Wie bekomme ich den Wert einer SERIAL-Sequenz?
   4.14.3) Führt currval() zu einer Race-Condition mit anderen Nutzern?
   4.14.4) Warum werden die Sequenzwerte nach einem Transaktionsabbruch
   nicht zurückgesetzt? Warum gibt es Lücken in der Nummerierung meiner
   Sequenz-/SERIAL-Spalte?
   4.15) Was ist ein OID? Was ist ein TID?
   4.16) Welche Bedeutung haben die verschiedenen Ausdrücke, die in
   PostgreSQL benutzt werden (z.B. attribute, class,...)?
   4.17) Wieso bekomme ich den Fehler: "FATAL: Memory exhausted in
   AllocSetAlloc()"?
   4.18) Wie kann ich feststellen, welche PostgreSQL-Version bei mir
   läuft?
   4.19) Bei "large-object"-Operationen kommt die Fehlermeldung: "invalid
   large obj descriptor". Warum?
   4.20) Wie kann ich eine Spalte erstellen, deren Default-Wert immer die
   aktuelle Uhrzeit enthalten soll?
   4.21) Warum sind meine Unterabfragen (subqueries), die IN verwenden,
   so langsam?
   4.22) Wie führe ich einen OUTER JOIN durch?
   4.23) Wie kann ich Abfragen über mehrere Datenbanken hinweg ausführen?
   4.24) Wie kann ich mehrere Zeilen bzw. Spalten von einer Funktion
   zurückgeben lassen?
   4.25) Warum kann ich temporäre Tabellen in PL/PgSQL-Funktionen nicht
   zuverlässig erstellen bzw. löschen?
   4.26) Welche Möglichkeiten zur Verschlüsselung gibt es?
   
                            PostgreSQL erweitern
                                      
   5.1) Ich habe eine benutzerdefinierte Funktion geschrieben. Wenn ich
   sie in psql aufrufe, kommt ein core dump. Warum?
   5.2) Wie kann ich praktische neue Typen und Funktionen zu PostgreSQL
   hinzufügen?
   5.3) Wie schreibe ich eine Funktion in C, die einen Tupel
   zurückliefert?
   5.4) Ich habe eine der Quellendateien geändert. Warum macht sich die
   Änderung beim erneuten Kompilieren nicht bemerkbar?
     _________________________________________________________________
   
                             Allgemeine Fragen
                                      
    1.1) Was ist PostgreSQL? Wie wird es ausgesprochen?
    
   Die (englische) Aussprache ist "Post-Gres-Q-L". Im allgemeinen
   Sprachgebrauch hat sich die Kurzform "Postgres" auch durchgesetzt.
   
   PostgreSQL ist eine Weiterentwicklung des POSTGRES-Datenbank-Systems,
   eines zukunftsweisenden DBMS-Forschungsprototyps. Während PostgreSQL
   das leistungsfähige Datenmodell und die reichhaltigen Datentypen von
   POSTGRES beibehält, ersetzt es dessen PostQuel-Abfragesprache durch
   eine erweiterte Teilmenge von SQL. PostgreSQL und dessen kompletter
   Quellcode sind frei und öffentlich verfügbar.
   
   Die PostgreSQL-Entwicklung wird von einem Entwickler-Team
   durchgeführt, die alle Teilnehmer der
   PostgreSQL-Entwicklungs-Mailingliste sind. Der aktuelle Koordinator
   ist Marc G. Fournier (scrappy@postgresql.org) (Anmeldemöglichkeit:
   siehe unten). Dieses Team ist für die Gesamtentwicklung von PostgreSQL
   verantwortlich. Es handelt sich um ein Gemeinschaftsprojekt, das nicht
   von einer bestimmten Firma kontrolliert wird. Lesen Sie die
   Entwickler-FAQ: http://www.postgresql.org/docs/faqs/FAQ_DEV.html wenn
   Sie an einer Mitarbeit interessiert sind.
   
   Die Autoren von PostgreSQL 1.01 waren Andrew Yu und Jolly Chen. Viele
   andere haben zur Portierung, zum Testen, zur Fehlersuche und zur
   Verbesserung des Codes beigetragen. Der ursprüngliche Postgres-Code,
   von dem PostgreSQL abstammt, ist auf die Arbeit von vielen
   Studierenden und Diplomanden sowie Programmierern zurückzuführen, die
   unter der Leitung des Professors Michael Stonebraker an der
   Universität von Kalifornien, Berkeley arbeiteten.
   
   Der ursprüngliche Name der Software in Berkeley war Postgres. Als die
   SQL-Funktionalität 1995 hinzugefügt wurde, wurde sein Name zu
   Postgres95 erweitert. Der Name wurde Ende 1996 in PostgreSQL geändert.
   
    1.2).Welchem Copyright unterliegt PostgreSQL?
    
   PostgreSQL unterliegt folgendem COPYRIGHT (Originaltext):
   
   PostgreSQL Data Base Management System
   
   Portions Copyright (c) 1996-2007, PostgreSQL Global Development Group
   Portions Copyright (c) 1994-6 Regents of the University of California
   
   Permission to use, copy, modify, and distribute this software and its
   documentation for any purpose, without fee, and without a written
   agreement is hereby granted, provided that the above copyright notice
   and this paragraph and the following two paragraphs appear in all
   copies.
   
   IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
   FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES,
   INCLUDING LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND
   ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN
   ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   
   THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
   INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
   PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
   CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
   UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
   
   Bei der obigen Lizenz handelt es sich um die BSD-Lizenz, die klassiche
   Open-Source-Lizenz. Sie schränkt die Verwendung des Quellcodes in
   keine Weise ein. Wir mögen diese Lizenz und haben nicht vor, sie zu
   ändern.
   
   Es gilt die Copyright-Klausel im Original!
   
    1.3) Auf welchen Unix-Plattformen läuft PostgreSQL?
    
   Normalerweise kann PostgreSQL auf jeder modernen UNIX-kompatiblen
   Plattform eingesetzt werden. Diejenigen Plattformen, die bei der
   jeweiligen Versionsfreigabe getestet wurden, sind in den
   Installations- Anleitungen aufgelistet.
   
    1.4) Welche Nicht-Unix-Portierungen sind verfügbar?
    
   Ab Version 8.0 läuft PostgreSQL auf Microsoft NT-basierten
   Betriebssystemen wie Windows 2000, XP und Server 2003. Ein
   vorgefertigtes Installationspaket (derzeit noch im Beta-Stadium) kann
   von http://pgfoundry.org/projects/pginstaller heruntergeladen werden.
   Einen Überblick über den aktuellen Stand bietet die Win32-FAQ:
   http://pginstaller.projects.postgresql.org/FAQ_windows.html.
   
   Unter Windows 95/98/ME ist es nur möglich, den Datenbankserver mit
   Hilfe der Cygwin-Umgebung (Unix-Portierungsbibliotheken) zu betreiben.
   Weitere Informationen hierzu gibt es in der CYGWIN-FAQ:
   http://www.postgresql.org/docs/faqs/text/FAQ_CYGWIN.
   
   Eine Portierung für Novell Netware 6 gibt es unter
   http://forge.novell.com.
   
   Für OS/2 (eComStation) gibt es eine Version hier:
   http://hobbes.nmsu.edu/cgi-bin/h-search?sh=1&button=Search&key=postgre
   SQL&stype=all&sort=type&dir=%2F
   
    1.5) Woher bekomme ich PostgreSQL?
    
   Der zentrale FTP-Server für PostgreSQL ist der ftp-Server
   ftp://ftp.postgresql.org/pub/. Weitere Mirror-Sites sind auf der
   PostgreSQL-Website aufgelistet.
   
    1.6) Wo bekomme ich Support für PostgreSQL?
    
   Die zentrale (englischsprachige) Mailing-Liste ist:
   mailto:pgsql-general@postgresql.org .
   
   Die Liste ist Themen vorbehalten, die PostgreSQL betreffen. Die
   Anmeldung erfolgt mit einer Email an die Adresse
   pgsql-general-request@postgresql.org mit folgenden Zeilen im Text
   (nicht in der Betreffzeile):
    subscribe
    end

   Es gibt auch eine Digest-Liste (eine Liste, die Mails zusammengefasst
   sendet). Um sich an dieser Digest-Liste anzumelden, senden Sie eine
   Email an pgsql-general-digest-request@postgresql.org mit folgendem
   Text:
    subscribe
    end

   Es gibt noch die Bug-Mailingliste. Die Anmeldung für diese Liste
   erfolgt durch eine Email an bugs-request@postgresql.org mit folgendem
   Text:
    subscribe
    end

   Die Entwickler-Mailingliste kann mit einer Email an
   pgsql-hackers-request@postgresql.org abonniert werden. Die Email muß
   ebenfalls folgenden Text enthalten:
    subscribe
    end

   Eine deutschsprachige Mailing-Liste gibt es ebenfalls:
   http://archives.postgresql.org/pgsql-de-allgemein/; die Liste kann
   hier abonniert werden.
   
   Weitere Mailinglisten und Informationen zu PostgreSQL befinden sich
   auf der PostgreSQL-Homepage:
   
     http://www.postgresql.org
     
   Es gibt außerdem einen IRC-Channel bei EFNet und bei Freenode, Channel
   #PostgreSQL. Unter UNIX/Linux können Sie mit z.B. irc -c '#PostgreSQL'
   "$USER" irc.freenode.net. bzw. irc -c '#PostgreSQL' "$USER"
   irc.phoenix.net daran teilnehmen.
   
   Eine Liste von Unternehmen, die Support für PostgreSQL auf
   kommerzieller Basis leisten, kann unter
   http://techdocs.postgresql.org/companies.php eingesehen werden.
   
    1.7) Was ist die neueste Version von PostgreSQL?
    
   Die neueste Version von PostgreSQL ist 8.0.0 .
   
   Die Freigabe einer neuen Version erfolgt im Schnitt alle 6 bis 8
   Monaten.
   
    1.8) Welche Dokumentation ist für PostgreSQL verfügbar?
    
   Einige Handbücher, Man-Pages und einige kleine Testprogramme sind in
   der Distribution enthalten. Siehe das /doc-Verzeichnis. Ausserdem sind
   alle Handbücher online unter http://www.postgresql.org/docs/
   verfügbar.
   
   Zwei Bücher zu PostgreSQL sind online verfügbar unter
   http://www.postgresql.org/docs/awbook.html und
   http://www.commandprompt.com/ppbook/ .
   
   Eine Liste lieferbarer PostgreSQL-Bücher befindet sich unter
   http://techdocs.postgresql.org/techdocs/bookreviews.php Diverse
   technische Artikel befinden sich unter http://techdocs.postgresql.org/
   .
   
   psql hat einige nützliche \d-Befehle, um Informationen über Typen,
   Operatoren, Funktionen, Aggregate, usw. zu zeigen.
   
    1.9) Wie erfahre ich von bekannten Bugs oder fehlenden Features?
    
   PostgreSQL unterstützt eine erweiterte Teilmenge von SQL-92. Siehe
   unsere TODO-Liste unter http://www.postgresql.org/docs/faqs.TODO.html
   für eine Auflistung der bekannten Bugs, fehlenden Features und
   zukünftigen Pläne.
   
    1.10) Wie kann ich SQL lernen?
    
   Das PostgreSQL Book auf http://www.postgresql.org/docs/awbook.html
   bietet eine Einführung in SQL. Ein weiteres PostgreSQL-Buch befindet
   sich unter http://www.commandprompt.com/ppbook . Es gibt zudem nette
   Tutorials unter http://www.intermedia.net/support/sql/sqltut.shtm ,
   http://ourworld.compuserve.com/homepages/graeme_birchall/HTM_COOK.HTM
   und http://sqlcourse.com .
   
   Eine weitere Empfehlung ist "Teach Yourself SQL in 21 Days, Second
   Edition", es ist unter http://members.tripod.com/er4ebus/sql/index.htm
   erhältlich.
   
   Viele PostgreSQL-Anwender mögen "The Practical SQL Handbook" (Bowman
   et al., Addison Wesley). Andere dagegen mögen "The Complete Reference
   SQL" (Groff et al., McGraw-Hill).
   
    1.11) Ist PostgreSQL Y2K (Jahr 2000) fähig?
    
   Ja, wir können Datumsangaben nach dem Jahr 2000 n.Chr. und vor 2000
   v.Chr. leicht verarbeiten.
   
    1.12) Wie kann ich im Entwicklerteam mitarbeiten?
    
   Zuerst laden Sie die neuesten Quellen herunter und lesen Sie die
   PostgreSQL-Entwicklerunterlagen auf unserer Website oder in der
   Distribution. Dann melden Sie sich zu den Entwickler-Mailinglisten
   pgsql-hackers und pgsql-patches an. Anschließend senden Sie qualitativ
   hochwertige Patches an die pgsql-patches Mailingliste.
   
   Es gibt ungefähr ein Dutzend Leute, die das commit-Recht im PostgreSQL
   CVS-Archiv haben. Alle haben derart viele hochwertige Patches
   eingebracht, dass es für die CVS-Verwalter schwer war, mitzuhalten.
   Und wir hatten Vertrauen, dass die von ihnen festgelegten Änderungen
   aller Wahrscheinlichkeit nach von hoher Qualität sind.
   
    1.13) Wie sende ich einen Fehlerbericht?
    
   Bitte besuchen Sie die PostgreSQL-BugTool-Seite
   http://www.postgresql.org/support/submitbug, die Hinweise und
   Anleitungen zur Einreichung von Fehlerberichten enthält.
   
   Überprüfe auch den ftp-Server ftp://ftp.postgresql.org/pub/, um
   nachzusehen, ob es eine neuere PostgreSQL-Version oder neue Patches
   gibt.
   
    1.14) Wie läuft PostgreSQL im Vergleich zu anderen Datenbanksystemen?
    
   Es gibt verschiedene Methoden, Software zu messen: Eigenschaften,
   Performanz, Zuverlässigkeit, Support und Preis.
   
   Eigenschaften
          PostgreSQL besitt die meisten Eigenschaften - wie
          Transaktionen, Unterabfragen (Subqueries), Trigger, Views und
          verfeinertes Locking - die bei großen kommerziellen DBMS
          vorhanden sind. Es bietet außerdem einige anderen
          Eigenschaften, die diese nicht immer haben, wie
          benutzerbestimmte Typen, Vererbung, Regeln, und die
          Multi-Versionen-Steuerung zum Verringern konkurrierender Locks.
          
   Performanz
          PostgreSQL weist eine Performanz auf, die mit der von
          kommerziellen und anderen Open-Source-Datenbanken vergleichbar
          ist. In manchen Bereichen ist es schneller, in anderen
          langsamer.
          
          Im Vergleich zu MySQL oder abgespeckten Datenbank-Systemen ist
          PostgreSQL in Lastsituationen - z.B. bei zeitgleichen Zugriffen
          durch mehrere Nutzer, bei komplexen Abfragen oder
          gleichzeitigen Lese- und Schreibzugriffen schneller. MySQL ist
          nur bei einfacheren SELECT-Abfragen mit wenigen Nutzern im
          Vorteil. MySQL besitzt allerdings nur wenige der im Punkt
          "Eigenschaften" genannten Features. PostgreSQL setzt auf
          Zuverlässigkeit und Funktionsumfang, dabei wird selbstredend
          ständig an Performanz-Verbesserungen gearbeitet.
          
   Zuverlässigkeit
          Es ist selbstredend, dass ein DBMS wertlos ist, wenn es nicht
          zuverlässig arbeitet. Daher bemühen wir uns, nur streng
          geprüften und beständigen Code freizugeben, der nur ein Minimum
          an Programmfehlern aufweist. Jede Freigabe hat mindestens einen
          Monat Betatest-Phase hinter sich, und unsere Freigabehistorie
          beweist, dass wir stabile und solide Versionen freigeben, die
          im Produktionsbetrieb genutzt werden können. Wir glauben, dass
          wir im Vergleich mit anderer Datenbanksoftware vorteilhaft
          dastehen.
          
   Support
          Unsere Mailinglisten bieten die Möglichkeit, gemeinsam mit
          einer großen Gruppe von Entwicklern und Benutzern mögliche
          Probleme zu lösen. Wir können nicht immer eine Fehlerbehebung
          garantieren, kommerzielle DBMS tun dies aber auch nicht. Der
          direkte Kontakt zur Entwickler- und Benutzergemeinschaft und
          der Zugriff auf die Handbücher und den Quellcode ermöglicht
          einen im Vergleich zu anderen DBMS höherwertigeren Support. Es
          gibt jedoch auch Anbieter von kommerziellen Support-Leistungen
          (siehe FAQ-Punkt 1.6).
          
   Preis
          PostgreSQL ist frei verfügbar, sowohl für die kommerzielle wie
          auch für die nicht-kommerzielle Nutzung. Sie können den
          PostgreSQL-Code ohne Einschränkungen (außer denjenigen, die in
          der oben angegebene BSD-artigen Lizenz erwähnt werden) in Ihr
          Produkt integrieren.
          
    1.15) Wie kann ich PostgreSQL finanziell unterstützen?
    
   PostgreSQL hat seit dem Anfang in 1996 eine exzellente Infrastruktur.
   Dies ist Marc Fournier zu verdanken, der sie über die Jahre hinweg
   geschaffen und gepflegt hat.
   
   Eine hochwertige Infrastruktur ist für ein Open-Source-Projekt wie
   dieses sehr wichtig. Sie verhindert Probleme und Verzögerungen beim
   Fortschritt des Projekts.
   
   Selbstverständlich ist diese Infrastruktur nicht billig. Es gibt eine
   Reihe von einmaligen und monatlich anfallenden Kosten, die für den
   Betrieb beglichen werden müssen. Falls Sie oder Ihre Firma dazu
   finanziell beitragen können, besuchen Sie bitte die URL
   http://store.pgsql.com/shopping/ wo Sie eine Spende abgeben können.
   
   Obwohl diese Web-Seite das Unternehmen "PostgreSQL, Inc." erwähnt, ist
   der Bereich "contributions" (Beiträge) ausschliesslich für die
   Unterstützung des PostgreSQL-Projekts da und nicht für die
   Finanzierung einer bestimmten Firma. Sie können auch gerne einen
   finanziellen Beitrag an die Kontaktadresse verschicken.
   
   Eine Möglichkeit der nicht-finanziellen Untetstützung besteht übrigens
   darin, für http://advocacy.postgresql.org (en.) bzw.
   http://advocacy.postgresql.org/?lang=de (dt.) einen Bericht über den
   erfolgreichen Einsatz von PostgreSQL in Ihrem Unternehmen oder in
   Ihrer Organisation bereitzustellen.
     _________________________________________________________________
   
                        Fragen zu Benutzerprogrammen
                                      
    2.1) Gibt es ODBC-Treiber für PostgreSQL?
    
   Es sind zwei ODBC-Treiber verfügbar: PsqlODBC und OpenLink ODBC.
   
   PsqlODBC kann von
   http://gborg.postgresql.org/project/psqlodbc/projdisplay.php
   heruntergeladen werden.
   
   OpenLink ODBC kann unter http://www.openlinksw.com bezogen werden. Die
   Software arbeitet mit dem Standard-ODBC-Client dieser Firma, so dass
   PostgreSQL-ODBC auf jeder Client-Plattform zur Verfügung steht, die
   unterstützt wird (Win, Mac, Unix, VMS).
   
   OpenLink wird dieses Produkt wahrscheinlich an Leute verkaufen, die
   kommerziellen Support benötigen, dennoch wird immer eine
   Freeware-Version verfügbar sein. Fragen dazu bitte an
   postgres95@openlink.co.uk.
   
    2.2) Welche Werkzeuge gibt es, um Web-Seiten mit PostgreSQL zu verbinden?
    
   Eine nette Einführung zu datenbank-gestützten Webseiten kann unter
   http://www.webreview.com (engl.) abgerufen werden.
   
   Für die Web-Integration ist PHP eine ausgezeichnete Schnittstelle. PHP
   gibt es bei http://www.php.net
   
   Für komplexere Aufgaben bietet sich die Perl-Schnittstelle mit CGI.pm
   oder mod_perl.
   
    2.3) Hat PostgreSQL eine grafische Benutzerschnittstelle?
    
   Es gibt mehrere grafische Schnittstellen für PostgreSQL, darunter
   PgAccess ( http://www.pgaccess.org), pgAdmin III
   (http://www.pgadmin.org, RHDB Admin (http://sources.redhat.com/rhdb/ )
   und Rekall ( http://www.thekompany.com/products/rekall/,
   GPL/proprietär). Es gibt außerdem phpPgAdmin (
   http://phppgadmin.sourceforge.net/ ), eine web-basierte Schnittstelle.
   
    2.4) Welche Programmiersprachen und Schnittstellen gibt es?
    
   Die meisten gängigen Programmiersprachen bieten Schnittstellen für
   PostgreSQL.
   
   Die folgenden Schnittstellen werden mit der PostgreSQL-Distribution
   ausgeliefert:
     * C (libpq)
     * Embedded C (ecpg)
     * Java (jdbc)
     * Python (PyGreSQL)
     * TCL (libpgtcl)
       
   Weitere Schnittstellen für andere Sprachen können über
   http://gborg.postgresql.org (Bereich Drivers/Interfaces) bezogen
   werden.
     _________________________________________________________________
   
                           Administrative Fragen
                                      
    3.1) Wie installiere ich PostgreSQL woanders als in /usr/local/pgsql?
    
   Bei der Ausführung von configure die Option --prefix mit dem
   Zielverzeichnis angeben.
   
    3.2) Wenn ich den postmaster starte, erhalte ich einen Nachricht "Bad
    System Call" bzw. "core dumped". Wieso?
    
   Das kann verschiedene Ursachen haben. Überprüfen Sie zuerst, ob Ihr
   Kernel System V Extensions unterstützt. PostgreSQL benötigt
   Kernel-Unterstützung für Shared Memory und Semaphoren.
   
    3.3) Wenn ich versuche, den postmaster zu starten, bekomme ich
    "IpcMemoryCreate"-Fehlermeldungen. Warum?
    
   Entweder ist Shared Memory in Ihrem Kernel nicht korrekt konfiguriert,
   oder Sie müssen den Shared Memory Bereich vergrößern. Die genaue Größe
   hängt von Ihrer Systemarchitektur und von der Anzahl der Puffer und
   Serverprozesse ab, die Sie für postmaster konfiguriert haben. Bei den
   voreingestellten Werten für Puffer und Prozesse benötigen Sie bei den
   meisten Systemen ein Minimum von ca. 1 MB. Der "PostgreSQL
   Administrator's Guide"
   (http://www.postgresql.org/docs/current/static/kernel-resources.html)
   enthält weitere Informationen zu Shared Memory und Semaphores.
   
    3.4) Wenn ich versuche, den postmaster zu starten, bekomme ich
    "IpcSemaphoreCreate"-Fehlermeldungen. Warum?
    
   Falls die Fehlermeldung "IpcSemaphoreCreate: semget failed (No space
   left on device)" lautet, ist Ihr Kernel mit zu wenig Semaphoren
   konfiguriert. PostgreSQL benötigt eine Semaphore pro möglichem
   Backend-Prozess. Eine Zwischenlösung wäre, postmaster mit einer
   geringeren Anzahl an Backend-Prozessen zu starten. Benutzen Sie dazu
   die -N Option mit einem kleineren Wert als die standardmäßigen 32.
   Eine dauerhafte Lösung wäre es, die Parameter SEMMNS und SEMMNI Ihres
   Kernels zu erhöhen.
   
   Nichtfunktionierende Semaphores können außerdem bei hoher
   Datenbanklast zu Abstürzen führen.
   
   Falls die Fehlermeldung anders aussieht, ist möglicherweise keine
   Semaphoren-Unterstützung in Ihrem Kernel aktiviert. Der "PostgreSQL
   Administrator's Guide" enthält weitere Informationen zu Shared Memory
   und Semaphores.
   
    3.5) Wie regle ich Zugriffe von anderen Rechnern?
    
   PostgreSQL ist standardmäßig so eingestellt, dass Verbindungen nur vom
   lokalen Rechner über Unix Domain Sockets möglich sind. Verbindungen
   von anderen Rechnern über TCP/IP sind nur möglich, wenn der postmaster
   mit der -i Option gestartet wird und / oder die Option
   listen_addresses (in 7.x-Versionen: tcpip_sockets) in postgresql.conf
   eingeschaltet wird, und die host-basierte Authentifizierung in der
   Datei $PGDATA/pg_hba.conf entsprechend angepasst ist.
   
    3.6) Wie optimiere ich die Datenbank für bessere Leistung?
    
   Der Einsatz von Indizes sollte auf jeden Fall Abfragen beschleunigen.
   Die Anweisung EXPLAIN ANALYZE zeigt, wie PostgreSQL Abfragen
   interpretiert und welche Indizes benutzt werden.
   
   Wenn Sie eine große Anzahl von INSERT-Anweisungen durchführen, sollten
   Sie überlegen, ob die Durchführung mit der COPY-Anweisung in Frage
   kommt. Dies funktioniert wesentlich schneller als einzelne
   INSERT-Befehle. SQL-Anweisungen, die sich nicht in einem BEGIN
   WORK/COMMIT Transaktions- Block befinden, werden als eigene
   Transaktionen behandelt. Überlegen Sie, ob die Anweisungen nicht in
   einen einzelnen Transaktionsblock zusammen- gefasst werden können. Das
   reduziert den Transaktionsaufwand. Überlegen Sie auch, bei größeren
   Datenänderungen Indizes zu löschen und danach wiederherzustellen.
   
   Es gibt verschiedene Tuning-Optionen, die im Handbuch dokumentiert
   sind (Administration Guide/Server Run-time Environment/Run-time
   Configuration). Sie können fsync() ausschalten, indem Sie beim Starten
   des postmaster die Optionen -o -F angeben. Das hindert
   fsync()-Operationen daran, nach jeder Transaktion die Daten direkt auf
   die Festplatte zu schreiben.
   
   Sie können auch mit der shared_buffers Option des postmaster die
   Anzahl der Shared Memory Puffer für die Backend-Prozesse erhöhen.
   Falls Sie diesen Wert jedoch zu hoch setzen, kann es vorkommen, dass
   der postmaster nicht startet, weil die Obergrenze der
   Speicherzuweisung für Shared Memory überschritten wird. Jeder Puffer
   ist 8 kB groß, voreingestellt sind 1000 Puffer.
   
   Die sort_mem (ab PostgreSQL 8.0: work_mem)-Optionen des Backends
   können benutzt werden, um die Größe des Speicherplatzes für temporäres
   Sortieren zu erhöhen. Die Werte werden in Kilobyte gemessen und sind
   standardmäßig auf 1024 (d.h. 1MB) festgelegt.
   
   Die CLUSTER-Anweisung kann benutzt werden, um Daten in Basistabellen
   zu gruppieren, so dass - um einen schnelleren Zugriff zu erreichen -
   die physikalische Speicherung der Reihenfolge eines der Indexe
   entspricht. Siehe auch die CLUSTER(l) Man-Page für weitere Details.
   
    3.7) Welche Debugging-Funktionen sind für PostgreSQL verfügbar?
    
   PostgreSQL hat einige Möglichkeiten, Statusinformationen anzuzeigen,
   die bei der Fehlersuche nützlich sein können.
   
   Wenn Sie PostgreSQL mit dem --enable-cassert Option kompiliert haben,
   verfolgen zahlreiche assert()-Anweisungen den Ablauf des Backends und
   halten das Programm an, wenn etwas Unerwartetes passiert.
   
   Sowohl der postmaster als auch postgres stellen mehrere Debug-Optionen
   zur Verfügung. Zuerst sollten Sie sichergehen, dass Sie die Ausgaben
   über den Standard-Output und den Standard-Error in eine Datei
   umleiten, wenn Sie den postmaster starten:
      cd /usr/local/pgsql
      ./bin/postmaster >server.log 2>&1 &

   Dadurch wird die Datei server.log im PostgreSQL-Verzeichnis erzeugt.
   Diese Datei enthält nützliche Informationen über Probleme oder Fehler,
   die im Server aufgetreten sind. postmaster hat eine -d Option, die
   noch detailliertere Informationen liefert. Zur -d Option wird eine
   Nummer angegeben, die den Debug-Level - also die Menge der berichteten
   Information - angibt. Achtung, hohe Debug-Levels erzeugen schnell
   große Logdateien!
   
   Wenn der postmaster nicht läuft, können Sie das postgres-Backend sogar
   von der Befehlszeile ausführen und eine SQL-Anweisung direkt eingeben.
   Dies ist allerdings nur für Debugging-Zwecke zu empfehlen. Beachten
   Sie, dass hierbei ein Zeilenumbruch, und nicht - wie sonst üblich -
   das Semikolon die SQL-Anweisung beendet. Falls Sie PostgreSQL mit
   Debugging-Symbolen kompiliert haben, können Sie mit einem Debugger
   sehen, was passiert. Da das Backend jedoch nicht vom postmaster
   gestartet wurde, läuft es nicht in der gleichen Umgebung und deshalb
   können einige locking-Vorgänge sowie die Kommunikation zwischen den
   Backends nicht reproduziert werden.
   
   Wenn der postmaster hingegen läuft, führen Sie psql in einem Fenster
   aus, ermitteln Sie die Prozessnummer (PID) des postgres-Prozesses, der
   von psql verwendet wird (mit SELECT pg_backend_pid()). Binden Sie
   einen Debugger an diese PID und führen Sie Abfragen von psql aus. Wenn
   Sie den postgres-Serverstart analysieren wollen, setzen Sie die
   Umgebungsvariable PGOPTIONS="-W n", und starten Sie dann psql. Dies
   verzögert den Start um n Sekunden, damit Sie einen Debugger an den
   Prozess binden und ggf. Breakpoints setzen können, bevor die
   Startsequenz begonnen wird.
   
   Es gibt verschiedene Einstellungen (die log_*-Gruppe), die diverse
   Server-Statistik ausgeben und daher bei der Fehlersuche und
   Performanzmessung sehr nützlich sein können.
   
   Sie können die Anwendung auch mit Profiling kompilieren, um zu sehen,
   welche Funktionen wieviel Ausführungszeit beanspruchen. Das Backend
   Profil wird im Verzeichnis pgsql/data/base/dbname abgelegt. Das
   Client-Profil wird in das aktuelle Verzeichnis abgelegt. Bitte
   beachtern Sie, dass unter Linux PostgreSQL mit der Option
   -DLINUX_PROFILE kompiliert werden muß, um Profiling nutzen zu können.
   
    3.8) Ich bekomme die Meldung "Sorry, too many clients", wenn ich eine
    Verbindung aufzubauen versuche. Warum?
    
   Sie müssen die maximale Anzahl der gleichzeitig ausführbaren Backend-
   Prozesse hochsetzen.
   
   Die Voreinstellung erlaubt 32 Prozesse. Sie können diese erhöhen,
   indem Sie den postmaster mit einem entsprechenden -N Parameter starten
   bzw. die Konfigurationsdatei postgresql.conf anpassen.
   
   Bitte beachten Sie, dass Sie auch -B auf ein Wert größer als die
   Voreinstellung von 64 setzen müssen, wenn Sie -N auf einen Wert höher
   als 32 setzen; -B muss mindestens das Doppelte von -N betragen, und
   einer besseren Performanz wegen sollte der Wert noch höher sein. Bei
   einer hohen Anzahl von Backend-Prozessen kann es vorkommen, dass Sie
   einige Unix-Kernel- Parameter ebenfalls erhöhen müssen. Folgende
   Parameter sind zu überprüfen: die Maximalgröße der Shared Memory
   Blocks SHMMAX; die Maximalanzahl der Semaphoren SEMMNS und SEMMNI; die
   maximale Anzahl von Prozessen NPROC; die maximale Anzahl von Prozessen
   pro User MAXUPRC; und die Maximalzahl der geöffneten Dateien NFILE und
   NINODE. Durch die Begrenzung der Anzahl erlaubter Backend-Prozesse
   wird verhindert, dass System-Ressourcen durch PostgreSQL aufgebraucht
   werden.
   
    3.9) Was befindet sich im Verzeichnis pgsql_tmp/?
    
   Dieses Verzeichnis enthält temporäre Dateien, die durch den query
   executor erzeugt werden. Wenn zum Beispiel eine Sortierung
   durchgeführt werden muß, um ein ORDER BY auszuführen, und diese
   Sortierung mehr Hauptspeicher benötigt, als mit dem Backend-Parameter
   -S erlaubt wurde, dann werden diese Dateien erzeugt, um die Daten dort
   zu auszulagern.
   
   Die temporären Dateien sollten automatisch gelöscht werden. Falls das
   Backend jedoch während einer Sortierung abstürzen sollte, bleiben sie
   erhalten. Nach einem Neustart des postmaster werden sie dann aber
   wieder automatisch gelöscht.
   
    3.10) Warum muß ich bei jeder neuen Hauptversion von PostgreSQL die
    komplette Datenbank exportieren und anschließend reimportieren?
    
   Zwischen "kleinen" PostgreSQL-Versionsänderungen (z.B. zwischen 7.2
   und 7.2.1) werden keine strukturellen Änderungen durchgeführt, wodurch
   ein erneutes Aus- und Einlesen der Daten nicht erforderlich ist.
   Allerdings wird bei "großen" Versionsänderungen (z.B. zwischen 7.2 und
   7.3) oft das interne Format der Systemtabellen und Datendateien
   angepasst. Diese Änderungen sind oft sehr komplex, wodurch die
   Rückwärtskompatibilität der Datendateien nicht gewährleistet werden
   kann. Durch das Exportieren werden die Daten in einem generischen
   Format ausgegeben, wodurch die Importierung in das neue interne Format
   ermöglicht wird.
   
   Bei Upgrades, bei denen keine Formatänderungen stattgefunden haben,
   kann das pg_upgrade-Skript benutzt werden, um die Daten ohne Aus- und
   Einlesen zu übertragen. Die jeweilige Dokumentation gibt an, ob für
   die betreffende Version pg_upgrade verfügbar ist.
   
    3.11) Welche Hardware eignet sich für den Betrieb mit PostgreSQL?
    
   PostgreSQL läuft auf fast jeder Hardware-Kombination. Im PC-Bereich
   gibt es allerdings sehr große Abweichungen in der Qualität. Für einen
   Arbeitsplatz- oder Entwicklungsrechner mag dies nicht so bedeutend
   sein, im Server-Betrieb jedoch lohnt sich auf jeden Fall die
   Investition in teurere Bestandteile (Stichwörter ECC-Speicher, SCSI,
   Hauptplatinen und Netzteile von namhaften Herstellern).
     _________________________________________________________________
   
                             Fragen zum Betrieb
                                      
    4.1) Worin besteht der Unterschied zwischen Binary Cursors und Normal
    Cursors?
    
   Vgl. die DECLARE Man-Page für eine Beschreibung.
   
    4.2) Wie wähle ich per SELECT-Anweisung nur die ersten paar Zeilen bzw.
    eine beliebige Zeile in einer Abfrage aus?
    
   Vgl. die FETCH Man-Page, oder benutzen Sie SELECT ... LIMIT... .
   
   Selbst wenn Sie nur die ersten paar Zeilen einer Tabelle abfragen
   möchten, muß unter Umständen die komplette Abfrage abgearbeitet
   werden. Ziehen Sie also möglichst eine Abfrage in Erwägung, die eine
   ORDER BY-Anweisung benutzt, welche wiederum auf indizierte Spalten
   verweist. In diesem Fall kann PostgreSQL direkt nach den gewünschten
   Zeilen suchen und braucht nicht jede mögliche Ergebniszeile
   abzuarbeiten.
   
   Bitte beachten Sie, dass mit PostgreSQL 7.3 die Syntax LIMIT n, m
   durch LIMIT n OFFSET m ersetzt wurde.
   
   Um eine beliebige Zeile auszuwählen, nutzen Sie ORDER BY random():
       SELECT spalte
         FROM tabelle
     ORDER BY random()
        LIMIT 1


    4.3) Wie finde ich heraus, welche Tabellen, Indizes, Datenbanken oder
    Benutzer in der Datenbank definiert sind? Wie bekomme ich die von psql
    verwendeten Abfragen?
    
   In psql zeigt der Befehl \dt eine Liste der Datenbanktabellen. Weitere
   psql-Befehle lassen sich mit \? anzeigen. Sie können sich die Datei
   pgsql/src/bin/psql/describe.c mit dem Quellcode für psql ansehen. Sie
   enthält die SQL-Abfragen, die die Backslash-Kommandos (\) ausführen.
   Sie können psql auch mit der -E Option starten. Danach gibt psql die
   Abfragen aus, die es bei der Ausführung der Befehle benutzt. Außerdem
   biete PostgreSQL ein SQL-kompatibles INFORMATION SCHEMA, das
   Metainformation über die Datenbank zur Verfügung stellt.
   
   Die Datei pgsql/src/tutorial/syscat.source enthält außerdem viele
   SELECT- Abfragen, mit deren Hilfe man Information über die
   Systemtabellen erhalten kann.
   
    4.4) Wie entferne ich eine Spalte aus einer Tabelle? Wie ändere ich den
    Datentyp einer Spalte?
    
   Der Syntax ALTER TABLE DROP COLUMN wird ab PostgreSQL 7.3 unterstützt.
   
   Bei früheren Versionen bietet das folgende Verfahren Ersatz:
      BEGIN;
      LOCK TABLE old_table;
      SELECT ...  -- alle außer der zu entfernenden Spalte hier auswählen
        INTO TABLE new_table
        FROM old_table;
      DROP TABLE old_table;
      ALTER TABLE new_table RENAME TO old_table;
      COMMIT;

   Um den Datentyp einer Spalte zu ändern, gehen Sie wie folgt vor:
       BEGIN;
       ALTER TABLE tabelle ADD COLUMN neue_spalte neuer_datentyp;
       UPDATE tabelle SET neue_spalte = CAST(alte_spalte AS neuer_datentyp);
       ALTER TABLE tabelle DROP COLUMN alte_spalte;
       COMMIT;


   Um den Speicherplatz freizugeben, der von der gelöschten Spalte
   verwendet wurde, führen Sie VACUUM FULL aus.
   
    4.5) Was ist die Maximalgröße für eine Zeile, eine Tabelle, eine Datenbank?
    
   Es bestehen folgende Obergrenzen:
    Maximale Größe eine Datenbank?           unbeschränkt (es existieren
                                               Datenbanken mit 32 TB)
    Maximale Größe einer Tabelle?            32 TB
    Maximale Größe einer Zeile?              1,6 TB
    Maximale Größe einer Spalte?             1 GB
    Maximale Anzahl von Zeilen in einer Tabelle?
                                             unbeschränkt
    Maximale Anzahl von Spalten in einer Tabelle?
                                             250-1600 je nach Spaltentyp
    Maximale Anzahl von Indizies für eine Tabelle?
                                             unbeschränkt

   Selbstverständlich sind dies theoretische Werte, die oft durch die
   verfügbaren Platten- und Speicherressourcen beschränkt werden. Extreme
   Größen können zu Leistungseinbußen führen.
   
   Die maximale Tabellengröße von 32 TB benötigt keine
   Large-File-Unterstützung im Betriebssystem. Große Tabellen werden in
   Dateien mit einer Größe von je 1 GB aufgeteilt, wodurch etwaige
   dateisystem-bedingte Beschränkungen nicht relevant sind.
   
   Die maximale Tabellengröße und die maximale Anzahl von Spalten können
   vervierfacht werden, indem man die Default-Blockgröße auf 32 KB
   heraufsetzt.
   
    4.6) Wieviel Plattenplatz wird benötigt, um die Daten aus einer typischen
    Textdatei abzuspeichern?
    
   Eine PostgreSQL-Datenbank kann beim Abspeichern einer einfachen
   Textdatei bis zu fünfmal mehr Platz gegenüber der eigentlichen Größe
   der Datei beanspruchen.
   
   Betrachten wir eine Datei mit 100.000 Zeilen mit einem Integer und
   einer Textbeschreibung pro Zeile. Gehen wir davon aus, dass die
   durchschnittliche Länge der Textbeschreibung 20 Byte beträgt. Die
   einfache Datei würde 2,8 MB groß sein. Die Größe der
   PostgreSQL-Datenbankdatei, die diese Daten enthält, liegt ungefähr bei
   6,4 MB:
    32 Bytes: jeder Zeilenkopf (ungefähr)
   +24 Bytes: ein Integer-Feld und ein Textfeld
   + 4 Bytes: Zeiger auf der Datenseite auf den Tupel
   -----------------------------------------------
    60 Bytes pro Zeile

   Die Größe einer Datenseite in PostgreSQL beträgt 8192 Bytes (8 KB),
   also:
   8192 Bytes pro Seite
   ---------------------   =  136 Zeilen pro Seite (abgerundet)
     64 Bytes pro Zeile

   100.000 Datenzeilen
   ------------------------  =  735 Datenbankseiten (aufgerundet)
       128 Zeilen pro Seite

   735 Datenbankseiten * 8192 Bytes pro Seite  =  6.021.120 Byte (6 MB)

   Indizes beanspruchen nicht so viel Platz. Da sie jedoch die Daten
   beinhalten, die sie indizieren, können auch sie sehr groß werden.
   
   NULL-Werte werden als Bitmaps gespeichert, wodurch sie sehr wenig
   Platz in Anspruch nehmen.
   
    4.7) Meine Abfragen sind langsam oder benutzen die Indizes nicht. Warum?
    
   Indizes werden nicht automatisch bei jeder Abfrage verwendet. Indizes
   werden nur dann verwendet, wenn die abzufragende Tabelle eine
   bestimmte Größe übersteigt, und die Abfrage nur eine kleine
   Prozentzahl der Tabellenzeilen abfragt. Der Grund hierfür ist der,
   dass die durch einen Index verursachten Festplattenzugriffe manchmal
   länger dauern würden als ein einfaches Auslesen aller Tabellenzeilen
   (sequentieller Scan).
   
   Um festzustellen, ob ein Index verwendet werden soll, braucht
   PostgreSQL Statistiken über die Tabelle. Diese Statistiken werden
   durch die Anweisungen VACUUM ANALYZE bzw. ANALYZE berechnet. Anhand
   der Statistiken kennt der Abfragenoptimierer die Anzahl der
   Tabellenzeilen und kann besser entscheiden, ob Indizes verwendet
   werden sollen. Statistiken sind auch bei der Ermittlung der optimalen
   JOIN-Reihenfolgen und -Methoden wertvoll. Daher sollten diese
   regelmässig durchgeführt werden, da sich der Inhalt einer Tabelle ja
   auch verändert
   
   In Versionen vor 8.0 werden Indizes oft nicht benutzt, wenn die
   jeweiligen Datentypen nicht genau übereinstimmen. Dies gilt besonders
   für Spalten mit numerischen und Integer-Werten.
   
   Indizes werden normalerweise nicht in ORDER BY-Abfrage oder in JOINs
   verwendet. Ein sequentieller Scan mit anschließendem explizitem
   Sortiervorgang ist normalerweise schneller als ein Index-Scan einer
   großen Tabelle. Jedoch wird bei einer Abfrage, in der LIMIT zusammen
   mit ORDER BY verwendet wird, oftmals ein Index verwendet, da nur ein
   kleiner Abschnitt der Tabelle zurückgeliefert wird. Dadurch wird es
   auch möglich, die Minimal- und Maximalwerte einer Abfrage unter
   Verwendung von Indizes zu ermitteln:
       SELECT spalte
         FROM tabelle
     ORDER BY spalte [ DESC ]
        LIMIT 1

   (Die Aggregatfunktionen MIN() und MAX() verwenden keine Indizes).
   
   Sollte es danach aussehen, also ob der Optimierer irrtümlich einen
   sequentiellen Scan ausführt, führen Sie SET enable_seqscan TO 'off'
   aus und prüfen Sie, ob die Indexabfrage dadurch scheller geworden ist.
   
   Bei der Nutzung von Wildcard-Operatoren wie LIKE oder ~, können
   Indizes nur unter bestimmten Umständen verwendet werden:
     * Das Suchmuster muss sich an Anfang des Strings befinden, d.h.:
          + LIKE-Suchmuster dürfen nicht mit % anfangen;
          + ~ (reguläre Ausdrücke) müssen mit ^ anfangen.
     * Das Suchmuster darf nicht mit einer Zeichenklasse (z.B. [a-e])
       beginnen.
       
   Suchmuster, die Gross- und Kleinschreibung nicht berücksichtigen (z.B.
   ILIKE bzw. ~*), verwenden keine Indizes. Stattdessen können
   funktionale Indizes verwendet werden, die im Punkt 4.12 beschrieben
   werden.
   
   Die Standard-Locale "C" muss während der Datenbank-Initialisierung mit
   initdb verwendet worden sein, da andere locales den nächstgrößten Wert
   nicht ermitteln können. Es ist allerdings möglich, einen besonderen
   text_pattern_ops-Index für solche Fälle zu erstellen.
   
    4.8) Auf welche Weise kann ich sehen, wie der Abfrage-Optimierer meine
    Abfrage auswertet?
    
   Vgl. die EXPLAIN Man-Page.
   
    4.9) Was ist ein R-Tree Index?
    
   Ein R-Tree Index wird benutzt, um räumliche Daten zu indizieren. Ein
   Hash-Index kann nicht für Bereichssuchen genutzt werden. Ein B-Tree
   Index kann nur für Bereichssuchen in eindimensionalen Daten genutzt
   werden. R-Trees können hingegen auch mit multi-dimensionalen Daten
   umgehen. Ein Beispiel: Wenn ein R-Tree Index auf ein Attribut vom Typ
   POINT gebildet wird, dann kann das System Abfragen wie z.B. "Zeige
   alle Punkte, die sich in einem umgebenden Rechteck befinden"
   effizienter beantworten.
   
   Die kanonische Veröffentlichung, die das originale R-Tree Design
   beschreibt, ist:
   
   Guttman, A. "R-Trees: A Dynamic Index Structure for Spatial
   Searching." Proc of the 1984 ACM SIGMOD Int'l Conf on Mgmt of Data,
   45-57.
   
   Sie können dieses Werk auch in Stonebrakers "Readings in Database
   Systems" finden.
   
   Die eingebauten R-Trees können Polygone und Rechtecke verarbeiten.
   Theoretisch können R-Trees auf eine hohe Anzahl von Dimensionen
   erweitert werden. Für die Praxis bedeutet eine solche Erweiterung
   allerdings eine Menge Arbeit und wir haben derzeit keinerlei
   Dokumentation darüber, wie das zu machen wäre.
   
    4.10) Was ist der "Genetic Query Optimizer"?
    
   Das GEQO-Modul in PostgreSQL soll dazu dienen, das Optimierungsproblem
   beim JOIN von vielen Tabellen auf der Basis genetischer Algorithmen
   (GA) zu lösen. Es ermöglicht die Behandlung von großen JOIN-Queries
   durch eine nicht-erschöpfende Suche.
   
    4.11) Wie verfahre ich bei der Suche mit regulären Ausdrücken und bei einer
    Suche, bei der Groß- und Kleinschreibweisen ignoriert werden? Wie verwende
    ich einen Index bei solchen Suchabfragen?
    
   Der Operator ~ wendet einen regulären Ausdruck an und ~* wendet ihn
   an, ohne die Groß- und Kleinschreibung zu beachten. Ebenso beachtet
   LIKE die Groß- und Kleinschreibung, und ILIKE nicht.
   
   Gleichheitsvergleiche, die Groß- und Kleinschreibung ignorieren,
   werden in der Regel so ausgedruckt:
      SELECT *
        FROM tabelle
       WHERE LOWER(spalte) = 'abc'

   Hier kann kein normaler Index benutzt werden. Legt man hingegen einen
   funktionalen Index an, so wird er auf jeden Fall verwendet:
      CREATE INDEX tabelle_index ON tabelle (LOWER(spalte))

    4.12) Wie ermittle ich in einer Abfrage, ob ein Feld NULL ist?
    
   Testen Sie die Spalte mit IS NULL bzw. IS NOT NULL.
   
    4.13) Was ist der Unterschied zwischen den verschiedenen CHAR-Typen?
    
Typ           interner Name   Bemerkungen
-------------------------------------------------
VARCHAR(n)    varchar         die Größe legt die Maximallänge fest; kein
                              Auffüllen mit Leerzeichen
CHAR(n)       bpchar          mit Leerzeichen gefüllt bis zur angegebenen Länge
TEXT          text            keine obere Schranke für die Länge
BYTEA         bytea           Bytearray mit variabler Länge (auch für
                              '\0'-Bytes geeignet)
"char"        char            1 Zeichen

   Der interne Name kommt vor allem in den Systemkatalogen und in manchen
   Fehlermeldungen vor.
   
   Die ersten vier Typen sind "varlena"-Typen (d.h. die ersten vier Bytes
   geben die Länge an, gefolgt von den Daten). Daher ist der tatsächlich
   belegte Platz immer etwas mehr als die deklarierte Feldgröße.
   Allerdings wird unter Umständen auf diese Datentypen Datenkompression
   durch das TOAST- Verfahren angewendet, womit der tatsächlich belegte
   Platz auch geringer als erwartet ausfallen kann.
   
   Für die Speicherung von Zeichenketten variabler Länge empfiehlt sich
   VARCHAR(n). Die maximale Länge eines VARCHAR(n)-Felds wird bei der
   Tabellendefinition festgelegt. TEXT setzt keine Längengrenze,
   allerdings gibt es eine systembedingte Obergrenze von 1 GB.
   
   CHAR(n) ist geeignet für die Speicherung von Zeichenketten, die alle
   die gleiche Länge haben. Bitte beachten Sie, dass CHAR(n) automatisch
   Zeichenketten bis zur definierten Feldlänge mit Leerzeichen ausfüllt,
   während bei VARCHAR(n) nur die tatsächlich eingegebene Zeichenkette
   gespeichert wird.
   
   BYTEA ist für binäre Daten, besonders für Werte, die NULL-Bytes haben.
   
   Alle der hier erwähnten Typen weisen ähnliche Performanzeigenschaften
   auf.
   
    4.14.1) Wie erzeuge ich ein serielles Feld mit automatischer Erhöhung des
    Werts (serial/auto-increment)?
    
   PostgreSQL bietet einen SERIAL-Datentyp. Dieser erzeugt automatisch
   eine Sequenz auf die angegebene Spalte. Zum Beispiel:
      CREATE TABLE person (
          id   SERIAL,
          name TEXT
      )

   wird automatisch in:
      CREATE SEQUENCE person_id_seq;
      CREATE TABLE person (
        id   INT4 NOT NULL DEFAULT nextval('person_id_seq'),
        name TEXT
      );

   umgewandelt.
   
   Die create_sequence Man-Page liefert weitere Informationen über
   Sequenzen. Es ist auch möglich, den OID-Wert jeder Spalte als
   einmaligen Wert einzusetzen. Sollten Sie allerdings die Datenbank
   exportieren und reimportieren wollen, müssen Sie die Option -o von
   pg_dump bzw. COPY WITH OIDS verwenden, um die OIDs beizubehalten.
   
    4.14.2) Wie bekomme ich den Wert einer SERIAL-Sequenz?
    
   Eine Möglichkeit wäre, mit der nextval()-Funktion den nächsten
   SERIAL-Wert von dem Sequenzobjekt vor der Auszuführung einer
   INSERT-Anweisung anzufordern und ihn dann explizit in die
   INSERT-Anweisung einzubinden. Anhand der Beispieltabelle in 4.14.1
   könnte dieser Vorgang in einer Pseudosprache so aussehen:
    new_id = output of execute("SELECT nextval('person_id_seq')");
    execute("INSERT INTO person (id, name) VALUES (new_id, 'Blaise Pascal')");

   Danach stünde der neue Wert in der Variablen new_id für die Verwendung
   in weiteren Abfragen zur Verfügung, zum Beispiel als Fremdschlüssel
   zur Tabelle 'person'). Bitte beachten Sie, dass der Name des
   automatisch erstellten SEQUENCE-Objektes folgenden Name hat:
   <table>_<serialcolumn>_seq wobei 'table' und 'serialcolumn' die Namen
   der jeweils betreffenden Tabelle / Spalte darstellen.
   
   Als weitere Möglichkeit können Sie nach einer INSERT-Anweisung den
   automatisch eingefügten SERIAL-Wert mit der currval()-Funktion
   zurückgeben lassen:
    execute("INSERT INTO person (id, name) VALUES (new_id, 'Blaise Pascal')");
    new_id = output of execute("SELECT currval('person_id_seq')");

   Schließlich besteht noch die Möglichkeit, den von einer
   INSERT-Anweisung zurückgelieferten OID-Wert als einmaligen Wert zu
   verwenden. Dieser Ansatz ist allerdings PostgreSQL-spezifisch;
   außerdem wird nach ca. 4 Milliarden Einträgen der OID-Wert wieder auf
   eine kleine Zahl gesetzt, ist also nicht garantiert immer einmalig
   oder aufsteigend.
   
   Mit zum Beispiel dem DBD::Pg-Modul von Perl wird der OID-Wert nach
   einem $sth->excute() über $sth->{pg_oid_status} zurückgeliefert.
   
    4.14.3) Führen currval() und nextval() zu einer Race-Condition mit anderen
    Nutzern?
    
   Nein. currval() liefert einen Wert zurück, der von Ihrem Backend
   bestimmt wird, und der anderen Benutzern nicht zur Verfügung steht.
   
    4.14.4) Warum werden die Sequenzwerte nach einem Transaktionsabbruch nicht
    zurückgesetzt? Warum gibt es Lücken in der Nummerierung meiner
    Sequenz-/SERIAL-Spalte?
    
   Um die gleichzeitige Abarbeitung von Transaktionen zu verbessern,
   werden Sequenzen gerade nicht für andere Transaktionen gesperrt,
   sondern die Sequenznummern werden den laufenden Transaktionen sofort
   zugeteilt. Lücken in der Sequenznummerierung werden durch abgebrochene
   Transaktionen verursacht.
   
    4.15) Was ist ein OID? Was ist ein TID?
    
   OIDs sind PostgreSQLs Antwort auf eindeutige Zeilen-IDs. Jede Zeile,
   die in PostgreSQL erzeugt wird, bekommt eine eindeutige OID. Alle
   OIDs, die durch initdb erzeugt werden, sind kleiner als 16384 (siehe
   include/access/transam.h). Alle OIDs, die durch den Benutzer erzeugt
   werden, sind größer oder gleich diesem Wert. Standardmäßig sind all
   OIDs nicht nur innerhalb einer Tabelle oder Datenbank, sondern in der
   gesamten PostgreSQL-Installation einmalig.
   
   PostgreSQL benutzt OIDs in seinen internen Systemtabellen, um Zeilen
   in JOINs zwischen Tabellen zu verknüpfen. Es ist möglich, einen Index
   für die OID-Spalte zu erstellen, wodurch schnellere Zugriffszeiten
   erreicht werden können. Es wird empfohlen, OID-Werte in Spalten vom
   Typ OID zu speichern.
   
   OIDs werden allen neuen Zeilen von einem zentralen Bereich, der von
   allen Datenbanken genutzt wird, zugewiesen. Nichts hindert Sie daran,
   die OID zu ändern, oder eine Kopie der Tabelle mit den originalen OIDs
   anzulegen:
        CREATE TABLE new_table(mycol int);
        SELECT oid AS old_oid, mycol INTO tmp_table FROM old_table;
        COPY tmp_table TO '/tmp/pgtable';
        COPY new_table WITH OIDS FROM '/tmp/pgtable';
        DROP TABLE tmp_table;

   OIDs werden als 4-Byte Integer gespeichert und laufen bei einem Wert
   von ungefähr 4 Milliarden über. Niemand hat jemals davon berichtet,
   dass dies passiert wäre aber wir haben geplant, diese Beschränkung
   aufzuheben, bevor das jemand ausprobieren kann.
   
   TIDs werden benutzt, um bestimmte physikalische Zeilen durch Block und
   Offset Werte zu identifizieren. TIDs verändern sich, sobald Zeilen
   verändert oder zurückgeladen werden. Sie werden in Indexeinträgen
   benutzt um auf die physikalischen Zeilen zu zeigen.
   
    4.16) Welche Bedeutung haben die verschiedenen Ausdrücke, die in PostgreSQL
    benutzt werden (z.B. attribute, class,...)?
    
   Einige der Quelltexte und die ältere Dokumentation nutzen allgemeine
   Begriffe. Hier sind einige aufgeführt:
     * row, record, tuple
     * attribute, field, column
     * table, class
     * retrieve, SELECT
     * replace, UPDATE
     * append, INSERT
     * OID, serial value
     * portal, cursor
     * range variable, table name, table alias
       
   Eine allgemeine Liste der Datenbank-Terminologie erhalten Sie hier:
   http://hea-www.harvard.edu/MST/simul/software/docs/pkgs/pgsql/glossary
   /glossary.html (engl.).
   
    4.17) Wieso bekomme ich einen Fehler: "ERROR: Memory exhausted in
    AllocSetAlloc()"?
    
   Wahrscheinlich gibt es keinen virtuellen Speicher mehr in Ihrem System
   oder Ihr Kernel hat niedrige Höchstgrenzen für bestimmte Ressourcen.
   Probieren Sie vor dem Start von postmaster folgendes:
      ulimit -d 262144
      limit datasize 256m

   Je nach benutzter Shell wird nur einer dieser Befehle erfolgreich
   ausgeführt werden. Auf jedem Fall wird die Grenze des Datensegments
   für Prozesse erhöht werden und eventuell die erfolgreiche Ausführung
   der Abfrage ermöglichen. Falls Sie ein Problem mit dem SQL-CLient
   haben, weil das Backend zu viele Daten zurückliefert, versuchen Sie
   dies vor dem Start des SQL-Clients.
   
    4.18) Wie kann ich feststellen, welche PostgreSQL-Version bei mir läuft?
    
   Geben Sie in psql SELECT VERSION(); ein.
   
    4.19) Bei "large-object"-Operationen kommt die Fehlermeldung: "invalid
    large obj descriptor". Warum?
    
   Sie sollten die Anweisungen BEGIN WORK und COMMIT bei jeden Gebrauch
   von Large Objects benutzen. Also um lo_open ... lo_close.
   
   Derzeit erzwingt PostgreSQL diese Regel, indem es die Handles der
   Large Objects beim COMMIT der Transaktion schließt. So führt der erste
   Versuch, etwas mit dem Large Object zu machen, zu einer Meldung
   "invalid large obj descriptor". Solange Sie keine Transaktionen
   benutzen, wird der Code, der in älteren PostgreSQL-Versionen
   funktionierte, nun diese Fehlermeldung erzeugen.
   
   Falls Sie eine Client-Schnittstelle wie ODBC benutzen, kann es sein,
   dass die auto-commit-Option ausgeschaltet werden muss.
   
    4.20) Wie kann ich eine Spalte erstellen, deren Default-Wert immer die
    aktuelle Uhrzeit enthalten soll?
    
   Dazu verwenden Sie CURRENT_TIMESTAMP:
      CREATE TABLE test (x int, modtime timestamp DEFAULT CURRENT_TIMESTAMP );

    4.21) Warum sind meine Unterabfragen (subqueries), die IN verwenden, so
    langsam?
    
   In Versionen vor 7.4 werden Unterabfragen mit der äusseren Abfrage
   verbunden, in dem für jede Reihe der äusseren Query die Ergebnisse der
   Unterabfrage sequentiell geprüft werden. Um dies zu vermeiden, kann
   man IN durch EXISTS ersetzen, z.B.:
      SELECT *
        FROM tabelle_1
       WHERE spalte1 IN (SELECT spalte2 FROM tabelle_2)

   ersetzen durch:
      SELECT *
        FROM tabelle_1
       WHERE EXISTS (SELECT spalte2 FROM tabelle_2 WHERE spalte1 = spalte2)

   Damit diese Abfrage effizient durchgeführt wird, sollte für 'spalte2'
   ein Index angelegt worden sein. Ab PostgreSQL 7.4 verwendet IN die
   gleichen Methoden wie die normale Tabellenverknüpfung und ist daher
   soger EXISTS vorzuziehen.
   
    4.22) Wie führe ich einen OUTER JOIN durch?
    
   PostgreSQL ab der Version 7.1 unterstützt OUTER JOINs nach dem SQL-
   Standardsyntax. Hier zwei Beispiele:
      SELECT *
        FROM tabelle_1 t1
             LEFT OUTER JOIN tabelle_2 t2 ON (t1.spalte = t2.spalte)

   bzw.:
      SELECT *
        FROM tabelle_1 t1
             LEFT OUTER JOIN tabelle_2 t2 USING (spalte)

   Diese identischen Abfragen verknüpfen tabelle_1 mit tabelle_2 über die
   Spalte 'spalte' und geben außerdem alle unverknüpften Zeilen in
   tabelle_1 (diejenigen, die keine Entsprechung in tabelle_2 haben)
   zurück. Ein RIGHT JOIN würde hingegen alle unverknüpften Zeilen in
   tabelle_2 hinzufügen und ein FULL JOIN würde alle verknüpften Zeilen
   sowie jeweils alle unverknüpften Zeilen aus den beiden Tabellen
   zurückliefern. Die Angabe von OUTER ist nicht zwingend und kann in
   LEFT, RIGHT und FULL-Verknüpfungen weggelassen werden. Normale
   Verknüpfungen sind INNER JOINs.
   
   In früheren Versionen von PostgreSQL konnten OUTER JOINs mittels UNION
   und NOT IN simuliert werden. Zum Beispiel 'tabelle_1' und 'tabelle_2'
   können als LEFT OUTER JOIN auch so verknüpft werden:
      SELECT t1.spalte1, t2.spalte2
        FROM tabelle_1 t1, tabelle_2 t2
       WHERE t1.spalte1 = t2.spalte1
       UNION ALL
      SELECT t1.spalte1, NULL
        FROM tabelle_1 t1
       WHERE t1.spalte1 NOT IN (SELECT t2.spalte1 FROM tabelle_2 t2)
       ORDER BY spalte1

    4.23) Wie kann ich Abfragen über mehrere Datenbanken hinweg ausführen?
    
   Es gibt keinen Weg, innerhalb einer Abfrage auf mehr als eine
   Datenbank zuzugreifen. Da PostgreSQL datenbank-spezifische
   Systemkataloge lädt, ist eine datenbankübergreifende Abfrage nicht
   möglich.
   
   contrib/dblink ist eine Erweiterung, die datenbankübergreifende
   Abfragen über Funktionsaufrufe ermöglicht.
   
   Es ist natürlich möglich, dass eine Client-Anwendung gleichzeitige
   Verbindungen zu verschiedenen Datenbanken aufbaut und selber
   Datensätze zusammenfügt.
   
   Ab 7.3 unterstützt PostgreSQL schemas, die die Aufteilung einer
   Datenbank in mehrere logische Bereiche ermöglichen. Bei vielen
   Anwendungen könnten diese einen geeigneten Ersatz für den Zugriff auf
   eine andere Datenbank bieten.
   
    4.24) Wie kann ich mehrere Zeilen bzw. Spalten von einer Funktion
    zurückgeben lassen?
    
   Ab 7.3 können Funktionen mehrere Zeilen und Spalten zurückgeben, vgl.:
   http://techdocs.postgresql.org/guides/SetReturningFunctions.
   
    4.25) Warum kann ich temporäre Tabellen in PL/PgSQL-Funktionen nicht
    zuverlässig erstellen bzw. löschen?
    
   PL/PgSQL verarbeitet die Inhalte einer Funktion in eine Cache. Dies
   hat eine unangenehme Nebenwirkung, nämlich dass wenn eine PL/PgSQL-
   Funktion auf eine temporäre Tabelle zugreift, und diese Tabelle
   anschließend gelöscht bzw. neu erstellt wird, die Funktion
   fehlschlagen wird, da die gecachten Funktionsinhalte noch auf die alte
   temporäre Tabelle zeigen.
   
   Die Lösung für diese Probleme besteht darin, in der PL/PgSQL Funktion
   mittels EXECUTE auf temporäre Tabellen zuzugreifen. Diese bewirkt,
   dass bei jedem Funktionsruf die betreffende Abfrage neu geparst wird.
   
    4.26) Welche Möglichkeiten zur Verschlüsselung gibt es?
    
     * contrib/pgcrypto enthält diverse Funktionen für die Benützung mit
       SQL-Abfragen.
     * Um Verbindungen zwischen dem Server und Client-Anwendungen zu
       verschlüsseln, muss in der Server-Konfigurationsdatei
       postgresql.conf die ssl-Option auf true (Voreinstellung: false)
       gesetzt werden und ein passender host- bzw. hostssl-Eintrag muss
       in pg_hba.conf vorhanden sein. Zudem muss die sslmode-Einstellung
       beim Client nicht auf disable gesetzt werden. (Bitte beachten Sie
       auch, daß neben der eingebauten SSL-Unterstützung verschlüsselte
       Verbindungen auch über externe Anwendungen wie stunnel oder ssh
       aufgebaut werden können).
     * Die Passwörter der Datenbanknutzer werden ab Version 7.3
       automatisch verschlüsselt (in früheren Versionen muß der Parameter
       PASSWORD_ENCRYPTION in postgresql.conf explizit eingeschaltet
       werden).
     * Betrieb des Servers auf einem verschlüsselten Dateisystem.
     _________________________________________________________________
   
                            PostgreSQL erweitern
                                      
    5.1) Ich habe eine benutzerdefinierte Funktion geschrieben. Wenn ich sie in
    psql aufrufe, kommt ein core dump. Warum?
    
   Dieses Problem kann viele Ursachen haben. Testen Sie Ihre Funktion
   zuerst in einem eigenen Testprogramm.
   
    5.2) Wie kann ich praktische neue Typen und Funktionen zu PostgreSQL
    hinzufügen?
    
   Senden Sie Ihre Beiträge an die Mailing Liste pgsql-hackers, und sie
   werden nach Prüfung eventuell ins contrib/ Verzeichnis des Quellcodes
   aufgenommen werden.
   
    5.3) Wie schreibe ich eine Funktion in C, die einen Tupel zurückliefert?
    
   Ab PostgreSQL 7.3 werden Funktionen, die Tupel zurückliefern, in C,
   PL/PgSQL und SQL unterstützt. Der Programmer's Guide enthält weitere
   Informationen dazu. Ein Bespiel einer solchen Funktion befindet sich
   in contrib/tablefunc.
   
    5.4) Ich habe eine der Quellendateien geändert. Warum macht sich die
    Änderung beim erneuten Kompilieren nicht bemerkbar?
    
   Die Makefiles enthalten nicht die richtigen Abhängigkeiten für
   include- Dateien. Sie müssen ein "make clean" und dann ein weiteres
   "make" ausführen. Wenn Sie gcc benutzen, können Sie die
   "--enable-depend"-Option des configure- Skripts benutzen, damit der
   Compiler die Abhängigkeiten automatisch ermittelt.
     _________________________________________________________________
   
    Anmerkungen des Übersetzers
    
   Die englische Vorlage dieser FAQ wird ständig überarbeitet. Daher
   liegt die Übersetzung nicht immer auf dem aktuellsten Stand.
   
   Die aktuellste Version der deutschen Übersetzung befindet sich immer
   unter http://sql-info.de/de/postgresql/FAQ_german.html. Diese
   "Arbeitsversion" enthält eventuell Änderungen, die noch nicht auf der
   PostgreSQL-Website eingebunden worden sind.
   
   Über Verbesserungshinweise und Korrekturvorschläge sowie
   Verständnisfragen zum Inhalt der FAQ freue ich mich. Ich nehme auch
   allgemeine Fragen zu PostgreSQL gerne entgegen, verweise jedoch auf
   die Mailing-Listen als schnelle und zuverlässige Anlaufstellen.
