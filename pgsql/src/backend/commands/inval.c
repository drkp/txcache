/*-------------------------------------------------------------------------
 *
 * inval.c
 *	  External cache invalidations
 *
 * IDENTIFICATION
 *	  $PostgreSQL$
 *
 *-------------------------------------------------------------------------
 */

#include "postgres.h"

#include "access/genam.h"
#include "access/hash.h"
#include "access/heapam.h"
#include "access/skey.h"
#include "access/xact.h"
#include "catalog/catalog.h"
#include "catalog/pg_type.h"
#include "commands/async.h"
#include "commands/inval.h"
#include "nodes/execnodes.h"
#include "nodes/pg_list.h"
#include "storage/lwlock.h"
#include "storage/shmem.h"
#include "utils/builtins.h"
#include "utils/datum.h"
#include "utils/memutils.h"
#include "utils/xstamp.h"
#include "funcapi.h"

#define MAX_PENDING_INVALIDATIONS 16384
#define MAX_INVALTAG_LEN 64
#define INVALIDATION_NOTIFY_RELNAME "invalidation"

/* Invalidations that are pending in the current transaction */
static HTAB *pendingInvalidations = NULL;

/* Invalidation tags gathered by the current query */
static HTAB *queryTags = NULL;

/* Invalidations that have been generated by transactions that have
 * already been committed */
typedef struct InvalidationQueueEntry {
	XStamp xstamp;
	bool null;
	char tag[MAX_INVALTAG_LEN];
	SHM_QUEUE link;
} InvalidationQueueEntry;

typedef struct InvalidationQueue
{
	SHM_QUEUE queue;
	SHM_QUEUE freeList;
	InvalidationQueueEntry entries[MAX_PENDING_INVALIDATIONS];
	XStamp lastInvalidation;
} InvalidationQueue;

static InvalidationQueue *invalQueue;

static LWLockId InvalidationLock;

void
InvalidationInit()
{
	bool found;
	int i;
	
	invalQueue = ShmemInitStruct("Cache Invalidation Queue",
								 sizeof(InvalidationQueue), &found);
	if (!found)
	{
		invalQueue->lastInvalidation = XStampMinusInfinity;
		SHMQueueInit(&invalQueue->queue);
		SHMQueueInit(&invalQueue->freeList);
		for (i = 0; i < MAX_PENDING_INVALIDATIONS; i++)
		{
			InvalidationQueueEntry *ent = &invalQueue->entries[i];
			strcpy(ent->tag, "");
			ent->xstamp = InvalidXStamp;
			SHMQueueInsertBefore(&invalQueue->freeList, &ent->link);
		}
	}
		
	InvalidationLock = LWLockAssign();
}

size_t
InvalidationShmemSize()
{
	return (sizeof(InvalidationQueue));
}

void
EnqueueInvalidate(const char *tag)
{
	char *entry;
	
	if (!XactInvalidated)
		Async_Notify(INVALIDATION_NOTIFY_RELNAME);
	
	XactInvalidated = true;
	
	if (pendingInvalidations == NULL)
	{
		HASHCTL ctl;
		ctl.keysize = MAX_INVALTAG_LEN;
		ctl.entrysize = MAX_INVALTAG_LEN;
		ctl.hcxt = CurTransactionContext;
		pendingInvalidations =
			hash_create("pendingInvalidations", 32, &ctl,
					HASH_ELEM | HASH_CONTEXT);
	}

	entry = hash_search(pendingInvalidations,
						tag, HASH_ENTER, NULL);
	Assert(entry != NULL);
}

static void
AddInvalidationToQueue(XStamp xstamp, const char *tag)
{
	InvalidationQueueEntry *ent;

	Assert(LWLockHeldByMe(InvalidationLock));
	ent = (InvalidationQueueEntry *)
		SHMQueueNext(&invalQueue->freeList, &invalQueue->freeList,
					 offsetof(InvalidationQueueEntry, link));
	if (!ent)
	{
		ereport(ERROR,
				(errcode(ERRCODE_OUT_OF_MEMORY),
				 errmsg("invalidation queue full; "
						"discarding invalidation")));
		Assert(false);
		return;
	}
	SHMQueueDelete(&ent->link);

	ent->xstamp = xstamp;
	ent->null = (tag == NULL);
	if (!ent->null)
		strcpy(ent->tag, tag);
	SHMQueueInsertBefore(&invalQueue->queue, &ent->link);	
}

void
AtCommit_Invalidate(XStamp xstamp)
{
	HASH_SEQ_STATUS status;
	char *tag;
	
	if (pendingInvalidations == NULL)
		return;
	
	LWLockAcquire(InvalidationLock, LW_EXCLUSIVE);

	Assert(xstamp > invalQueue->lastInvalidation);
	invalQueue->lastInvalidation = xstamp;

	hash_seq_init(&status, pendingInvalidations);
	
	while ((tag = hash_seq_search(&status)) != NULL)
	{
		AddInvalidationToQueue(xstamp, tag);
	}
	LWLockRelease(InvalidationLock);

	DropPendingInvalidations();
}

void
DropPendingInvalidations()
{
	hash_destroy(pendingInvalidations);
	pendingInvalidations = NULL;
}

void
SendNullInvalidation(XStamp xstamp)
{
	LWLockAcquire(InvalidationLock, LW_EXCLUSIVE);
	if (invalQueue->lastInvalidation >= xstamp)
	{
		// no point in sending this null invalidation
		LWLockRelease(InvalidationLock);
		return;
	}
	invalQueue->lastInvalidation = xstamp;

 	AddInvalidationToQueue(xstamp, NULL);
	LWLockRelease(InvalidationLock);
	Async_Notify(INVALIDATION_NOTIFY_RELNAME);
}

typedef struct
{
	int n, i;
	InvalidationQueueEntry entries[MAX_PENDING_INVALIDATIONS];
} InvalidationResultContext;

Datum
pg_get_and_clear_invalidations(PG_FUNCTION_ARGS)
{
	FuncCallContext *funcctx;
	InvalidationResultContext *ctx;

	if (SRF_IS_FIRSTCALL())
	{
		TupleDesc	tupdesc;
		MemoryContext oldcontext;
		InvalidationQueueEntry *ent;
		
		funcctx = SRF_FIRSTCALL_INIT();

		oldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);

		tupdesc = CreateTemplateTupleDesc(2, false);
		TupleDescInitEntry(tupdesc, (AttrNumber) 1, "xstamp",
						   INT4OID, -1, 0);
		TupleDescInitEntry(tupdesc, (AttrNumber) 2, "tag",
						   TEXTOID, -1, 0);
		funcctx->tuple_desc = BlessTupleDesc(tupdesc);

		/* Allocate context */
		ctx = palloc(sizeof(InvalidationResultContext));
		funcctx->user_fctx = ctx;
		
		MemoryContextSwitchTo(oldcontext);

		ctx->i = 0;
		ctx->n = 0;
		
		/* Grab entries from invalidation queue and clear it */
		LWLockAcquire(InvalidationLock, LW_EXCLUSIVE);
		while (!SHMQueueEmpty(&invalQueue->queue))
		{
			ent = (InvalidationQueueEntry *)
				SHMQueueNext(&invalQueue->queue, &invalQueue->queue,
							 offsetof(InvalidationQueueEntry,
									  link));
			
			SHMQueueDelete(&ent->link);
			ctx->entries[ctx->n] = *ent;
			SHMQueueInsertBefore(&invalQueue->freeList, &ent->link);
			ctx->n++;
		}
		LWLockRelease(InvalidationLock);
	}

	funcctx = SRF_PERCALL_SETUP();
	ctx = funcctx->user_fctx;

	while (ctx->i < ctx->n)
	{
		Datum values[2];
		char nulls[2];
		HeapTuple tuple;
		Datum result;

		MemSet(nulls, ' ', sizeof(nulls));
		values[0] = UInt32GetDatum(ctx->entries[ctx->i].xstamp);
		if (ctx->entries[ctx->i].null)
			nulls[1] = 'n';
		else
			values[1] = DirectFunctionCall1(textin,
											CStringGetDatum(
												ctx->entries[ctx->i].tag));
		
		tuple = heap_formtuple(funcctx->tuple_desc, values, nulls);
		result = HeapTupleGetDatum(tuple);


		ctx->i++;

		SRF_RETURN_NEXT(funcctx, result);
	}

	SRF_RETURN_DONE(funcctx);
}

static size_t 
snprintfcat(char* buf, size_t bufSize, char const* fmt, ...)
{
    size_t result;
    va_list args;
    size_t len = strnlen(buf, bufSize);

    va_start(args, fmt);
    result = vsnprintf(buf + len, bufSize - len, fmt, args);
    va_end(args);

    return result + len;
}

static const char *
MakeInvalTagFromRelation(Relation rel)
{
	static char buf[MAX_INVALTAG_LEN];

	snprintf(buf, sizeof(buf), "%x:",
			 rel->rd_id);

	return buf;
}

static const char *
MakeInvalTagFromScanKey(Relation rel, Relation index, int nKeys, ScanKey keys)
{
	static char buf[MAX_INVALTAG_LEN];
	uint32 hash;
	int16 typeLen;
	bool typeByVal;
	int i;
	
	if (!index || !keys)
		return MakeInvalTagFromRelation(rel);

	for (i = 0; i < nKeys; i++)
	{
		if (keys[i].sk_strategy != BTEqualStrategyNumber)
			return MakeInvalTagFromRelation(rel);		
	}

	snprintf(buf, sizeof(buf), "%x:%x.",
			 rel->rd_id, index->rd_id);

	for (i = 0; i < nKeys; i++)
	{
		ScanKey key = &keys[i];
		Assert(key->sk_attno == i+1);
		typeLen = index->rd_att->attrs[key->sk_attno-1]->attlen;
		typeByVal = index->rd_att->attrs[key->sk_attno-1]->attbyval;
		
		if (typeByVal)
			hash = (uint32) key->sk_argument;
		else
		{
			Size realSize;
			realSize = datumGetSize(key->sk_argument, typeByVal, typeLen);
			hash = DatumGetUInt32(hash_any((unsigned char *)key->sk_argument,
										   realSize));
		}
		snprintfcat(buf, sizeof(buf), "%s%x",
					((i != 0) ? "," : ""), hash);
	}
	snprintfcat(buf, sizeof(buf), ":");

	return buf;
}

static const char *
MakeInvalTagFromValues(Relation rel, Relation index,
					   IndexInfo *indexInfo,
					   Datum *values, bool *isnull)
{
	static char buf[MAX_INVALTAG_LEN];
	uint32 hash;
	int16 typeLen;
	bool typeByVal;
	int i;
	
	if (!index)
		return MakeInvalTagFromRelation(rel);

	Assert(indexInfo->ii_NumIndexAttrs > 0);

	snprintf(buf, sizeof(buf), "%x:%x.",
			 rel->rd_id, index->rd_id);

	for (i = 0; i < indexInfo->ii_NumIndexAttrs; i++)
	{
		typeLen = index->rd_att->attrs[i]->attlen;
		typeByVal = index->rd_att->attrs[i]->attbyval;

		if (typeByVal)
			hash = (uint32) values[0];
		else
		{
			Size realSize;
			realSize = datumGetSize(values[i], typeByVal, typeLen);
			hash = DatumGetUInt32(hash_any((unsigned char *)values[i],
										   realSize));
		}
		snprintfcat(buf, sizeof(buf), "%s%x",
					((i != 0) ? "," : ""), hash);
	}
	snprintfcat(buf, sizeof(buf), ":");
	
	return buf;	
}

void
InitQueryTagSet(MemoryContext ctx)
{
	HASHCTL ctl;
	ctl.keysize = MAX_INVALTAG_LEN;
	ctl.entrysize = MAX_INVALTAG_LEN;
	ctl.hcxt = ctx;

	queryTags =
		hash_create("pendingInvalidations", 32, &ctl,
					HASH_ELEM | HASH_CONTEXT);	
}

const char *
GetQueryTagSet()
{
	static char buf[1024];
	HASH_SEQ_STATUS status;
	char *tag;

	snprintf(buf, sizeof(buf), " TAGS %ld",
			 hash_get_num_entries(queryTags));
	
	hash_seq_init(&status, queryTags);
	
	while ((tag = hash_seq_search(&status)) != NULL)
	{
		snprintfcat(buf, sizeof(buf), " %s", tag);

	}
	
	return buf;
}

void
AddInvalidationTag(Relation rel, Relation index, int nKeys, ScanKey keys)
{
	const char *tag;
	char *entry;

	if (IsSystemRelation(rel))
		return;

	if (!IsXactIsoLevelSerializable)
		return;

	tag = MakeInvalTagFromScanKey(rel, index, nKeys, keys);
	
	/* 
     * ereport(WARNING,
	 * 		(errcode(ERRCODE_WARNING),
	 * 		 errmsg("invalidation tag: %s", tag)));
     */

	entry = hash_search(queryTags,
						tag, HASH_ENTER, NULL);
	Assert(entry != NULL);

}

void
InvalidateTag(Relation rel, Relation index, IndexInfo *indexInfo,
			  Datum *values, bool *isnull)
{
	const char *tag;

	if (IsSystemRelation(rel))
		return;

	if (!IsXactIsoLevelSerializable)
		return;

	tag = MakeInvalTagFromValues(rel, index, indexInfo, values, isnull);

	/* 
     * ereport(WARNING,
	 * 		(errcode(ERRCODE_WARNING),
	 * 		 errmsg("invalidating: %s", tag)));
     */

	EnqueueInvalidate(tag);
}
